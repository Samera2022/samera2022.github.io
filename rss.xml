<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Samera2022</title><description>Lib</description><link>https://samera2022.github.io/</link><language>zh_CN</language><item><title>二叉搜索树DFS的三序遍历</title><link>https://samera2022.github.io/posts/notes/ds/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91dfs%E7%9A%84%E4%B8%89%E5%BA%8F%E9%81%8D%E5%8E%86/</link><guid isPermaLink="true">https://samera2022.github.io/posts/notes/ds/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91dfs%E7%9A%84%E4%B8%89%E5%BA%8F%E9%81%8D%E5%8E%86/</guid><description>对二叉搜索树DFS的一些简易理解方法</description><pubDate>Sat, 07 Feb 2026 04:27:00 GMT</pubDate><content:encoded>&lt;p&gt;二叉搜索树DFS共有三种遍历方式，分别为“前序遍历”、“中序遍历”与“后序遍历”。让我们先考虑以下一种简单的DFS算法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void order(TreeNode *root) {
    if (root == nullptr)
        return;
    order(root-&amp;gt;left);
    order(root-&amp;gt;right);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显然地，该代码会尝试&lt;code&gt;左侧优先&lt;/code&gt;遍历整个二叉树，具体模式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;res/20260207-01.png&quot; alt=&quot;模式图&quot; /&gt;&lt;/p&gt;
&lt;p&gt;让我们先给出这三种遍历方式的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 前序遍历 */
void preOrder(TreeNode *root) {
    if (root == nullptr)
        return;
    // 访问优先级：根节点 -&amp;gt; 左子树 -&amp;gt; 右子树
    vec.push_back(root-&amp;gt;val);
    preOrder(root-&amp;gt;left);
    preOrder(root-&amp;gt;right);
}

/* 中序遍历 */
void inOrder(TreeNode *root) {
    if (root == nullptr)
        return;
    // 访问优先级：左子树 -&amp;gt; 根节点 -&amp;gt; 右子树
    inOrder(root-&amp;gt;left);
    vec.push_back(root-&amp;gt;val);
    inOrder(root-&amp;gt;right);
}

/* 后序遍历 */
void postOrder(TreeNode *root) {
    if (root == nullptr)
        return;
    // 访问优先级：左子树 -&amp;gt; 右子树 -&amp;gt; 根节点
    postOrder(root-&amp;gt;left);
    postOrder(root-&amp;gt;right);
    vec.push_back(root-&amp;gt;val);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察发现三者在代码上较为相似，区别仅体现在将节点数据存入列表时的语句位置略有不同。这说明三者的节点遍历逻辑是完全一致的，仅仅在节点数据存入顺序上存在差异。&lt;/p&gt;
&lt;p&gt;让我们进一步对节点存入顺序进行分析，不难发现以下事实：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历采用&lt;code&gt;数据优先&lt;/code&gt;的策略，因而到达每个节点后会直接存入对应数据。&lt;/li&gt;
&lt;li&gt;中序遍历采用&lt;code&gt;左侧优先&lt;/code&gt;的策略，因而到达每个节点的左侧叶节点 |1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;6| 后才会开始存入数据。&lt;/li&gt;
&lt;li&gt;后序遍历采用&lt;code&gt;遍历优先&lt;/code&gt;的策略，因而到达每个节点的叶节点后才会开始存入数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三者在宏观上体现为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历存入数据顺序完全符合遍历顺序。&lt;/li&gt;
&lt;li&gt;中序遍历存入数据顺序按左叶节点优先，遍历顺序为次存入数据。&lt;/li&gt;
&lt;li&gt;后序遍历存入数据顺序按子节点优先，遍历顺序为次存入数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该二叉树DFS遍历顺序为：  1  -&amp;gt;  2  -&amp;gt;  4  -&amp;gt;  2  -&amp;gt;  5  -&amp;gt;  2  -&amp;gt;  1  -&amp;gt;  3  -&amp;gt;  6  -&amp;gt;  3  -&amp;gt;  7  -&amp;gt;  3  -&amp;gt;  1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历存入的顺序为： |1| -&amp;gt; |2| -&amp;gt; |4| -&amp;gt;  2  -&amp;gt; |5| -&amp;gt;  2  -&amp;gt;  1  -&amp;gt; |3| -&amp;gt; |6| -&amp;gt;  3  -&amp;gt; |7| -&amp;gt;  3  -&amp;gt;  1&lt;/li&gt;
&lt;li&gt;中序遍历存入的顺序为：  1  -&amp;gt;  2  -&amp;gt; |4| -&amp;gt; |2| -&amp;gt; |5| -&amp;gt;  2  -&amp;gt; |1| -&amp;gt; |3| -&amp;gt; |6| -&amp;gt;  3  -&amp;gt; |7| -&amp;gt;  3  -&amp;gt;  1&lt;/li&gt;
&lt;li&gt;后序遍历存入的顺序为：  1  -&amp;gt;  2  -&amp;gt; |4| -&amp;gt;  2  -&amp;gt; |5| -&amp;gt; |2| -&amp;gt;  1  -&amp;gt;  3  -&amp;gt; |6| -&amp;gt;  3  -&amp;gt; |7| -&amp;gt; |3| -&amp;gt; |1|&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将回溯纳入考虑，记为井号：
该二叉树DFS遍历顺序为：  1  -&amp;gt;  2  -&amp;gt;  4  -#  2  -&amp;gt;  5  -#  2  -#  1  -&amp;gt;  3  -&amp;gt;  6  -#  3  -&amp;gt;  7  -#  3  -#  1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历存入的顺序为： |1| -&amp;gt; |2| -&amp;gt; |4| -#  2  -&amp;gt; |5| -#  2  -#  1  -&amp;gt; |3| -&amp;gt; |6| -#  3  -&amp;gt; |7| -#  3  -#  1&lt;/li&gt;
&lt;li&gt;中序遍历存入的顺序为：  1  -&amp;gt;  2  -&amp;gt; |4| -# |2| -&amp;gt; |5| -#  2  -# |1| -&amp;gt; |3| -&amp;gt; |6| -#  3  -&amp;gt; |7| -#  3  -#  1&lt;/li&gt;
&lt;li&gt;后序遍历存入的顺序为：  1  -&amp;gt;  2  -&amp;gt; |4| -#  2  -&amp;gt; |5| -# |2| -#  1  -&amp;gt;  3  -&amp;gt; |6| -#  3  -&amp;gt; |7| -# |3| -# |1|&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;观察发现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历&lt;code&gt;遇到新元素会直接存入列表&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;中序排列在抵达该节点的左叶节点后&lt;code&gt;遇到新元素会直接存入列表&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;后序排列较为复杂，在抵达叶节点时直接存入，在左右子叶均抵达后回溯到达非叶节点时直接存入。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进行统一表述，可以得到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三者在抵达叶节点时均会直接存入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面对新元素 |未存入数据的节点| 的策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历未抵达左侧全体叶节点、未抵达右侧全体叶节点时&lt;code&gt;遇到新元素会直接存入列表&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;中序排列已抵达左侧全体叶节点、未抵达右侧全体叶节点时&lt;code&gt;遇到新元素会直接存入列表&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;后序排列已抵达左侧全体叶节点、已抵达右侧全体叶节点时&lt;code&gt;遇到新元素会直接存入列表&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::info
本文中所用到的代码与图片出自Hello算法，地址为：https://www.hello-algo.com/chapter_tree/binary_tree_traversal/#1_1
:::&lt;/p&gt;
</content:encoded></item><item><title>Find Us on AlternativeTo - Growing the MouseMacros Community</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-availableonaltto/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-availableonaltto/</guid><description>MouseMacros is now live on AlternativeTo! Help the community find a better, lightweight automation choice.</description><pubDate>Thu, 05 Feb 2026 13:40:00 GMT</pubDate><content:encoded>&lt;p&gt;Another exciting update for today: &lt;strong&gt;MouseMacros&lt;/strong&gt; is now officially listed on &lt;strong&gt;AlternativeTo&lt;/strong&gt;, the premier platform for crowdsourced software recommendations.&lt;/p&gt;
&lt;p&gt;Check out our profile and help us grow:
&lt;a href=&quot;https://alternativeto.net/software/mousemacros/about/&quot;&gt;MouseMacros on AlternativeTo&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Helping Others Discover a Better Choice&lt;/h3&gt;
&lt;p&gt;AlternativeTo is where users go to find leaner, faster, and more private alternatives to mainstream software. By joining this platform, we are positioning MouseMacros as a viable, open-source alternative to heavy automation suites.&lt;/p&gt;
&lt;p&gt;Our listing highlights our core strengths:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Task Automation&lt;/strong&gt;: Focused on efficiency.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Privacy Focused&lt;/strong&gt;: 100% local, no telemetry.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lightweight &amp;amp; Portable&lt;/strong&gt;: Single executable (EVB-boxed) or MSI.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ad-Free&lt;/strong&gt;: Open source as it should be.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;How You Can Help&lt;/h3&gt;
&lt;p&gt;If MouseMacros has helped you automate your workflow or save time in games like &lt;em&gt;Stellaris&lt;/em&gt;, please consider:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Liking&lt;/strong&gt; our page on AlternativeTo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Leaving a review&lt;/strong&gt; to share your experience with other users.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Your feedback helps the project gain visibility and shows potential users that there is a trustworthy, lightweight option available for their automation needs.&lt;/p&gt;
&lt;p&gt;Stay tuned for more updates, and as always, thank you for being part of this journey!&lt;/p&gt;
</content:encoded></item><item><title>MouseMacros Awarded &quot;100% Clean&quot; Excellence by Softpedia</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-availableonsoftpedia/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-availableonsoftpedia/</guid><description>A major security milestone - MouseMacros is now officially listed and certified by Softpedia.</description><pubDate>Thu, 05 Feb 2026 02:00:00 GMT</pubDate><content:encoded>&lt;p&gt;I am proud to announce that &lt;strong&gt;MouseMacros&lt;/strong&gt; has been officially reviewed and listed by &lt;strong&gt;Softpedia&lt;/strong&gt;, one of the world&apos;s largest and most respected software download hubs.&lt;/p&gt;
&lt;p&gt;You can view our official Softpedia page here:
&lt;a href=&quot;https://www.softpedia.com/get/System/OS-Enhancements/MouseMacros.shtml&quot;&gt;MouseMacros on Softpedia&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;A Badge of Trust&lt;/h3&gt;
&lt;p&gt;Softpedia is known for its rigorous testing process. We are thrilled to share that MouseMacros has been granted the &lt;strong&gt;&quot;100% Free&quot; Softpedia Award&lt;/strong&gt;. This certification means that their technical team has tested our software and confirmed they are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Free of Malware, Spyware, and Adware.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Safe to install&lt;/strong&gt; and run on any Windows environment.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For a tool that interacts with system-level inputs, this third-party validation is invaluable. It serves as another layer of assurance alongside our recent &lt;strong&gt;Microsoft Security Intelligence&lt;/strong&gt; clearance.&lt;/p&gt;
&lt;h3&gt;Why This Matters&lt;/h3&gt;
&lt;p&gt;Being listed on Softpedia helps users discover MouseMacros in a trusted environment. Whether you prefer downloading via the &lt;strong&gt;Microsoft Store&lt;/strong&gt;, &lt;strong&gt;SourceForge&lt;/strong&gt;, or now &lt;strong&gt;Softpedia&lt;/strong&gt;, you can be certain that the code is transparent and the app is verified.&lt;/p&gt;
</content:encoded></item><item><title>MouseMacros Now Available on the Microsoft Store</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-availableonmsstore/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-availableonmsstore/</guid><description>A major milestone for MouseMacros - officially published to the Microsoft Store for a more secure and seamless experience.</description><pubDate>Tue, 03 Feb 2026 14:27:00 GMT</pubDate><content:encoded>&lt;p&gt;I’m excited to announce that &lt;strong&gt;MouseMacros&lt;/strong&gt; has expanded its &lt;strong&gt;distribution channels&lt;/strong&gt;. While the software remains a Windows-native tool, you can now get the Store Edition directly from the Microsoft Store, alongside our traditional standalone releases on GitHub and SourceForge.&lt;/p&gt;
&lt;p&gt;You can click &lt;a href=&quot;https://apps.microsoft.com/detail/9mx3kfbkmn1h&quot;&gt;here&lt;/a&gt; to install it directly.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;res/20260203-01.png&quot; alt=&quot;Pic&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Why the Microsoft Store?&lt;/h1&gt;
&lt;p&gt;Bringing &lt;strong&gt;MouseMacros&lt;/strong&gt; to the official Store was more than just adding a download link; it was about addressing the most significant hurdle: &lt;strong&gt;Trust and Security.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As many of you know, automation tools that use low-level system hooks are often flagged as &quot;False Positives&quot; by antivirus software. By launching on the Microsoft Store, we’ve achieved several critical goals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Official Security Verification&lt;/strong&gt;: Every submission is rigorously scanned and manually reviewed by Microsoft to ensure it is free of malware.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Official Code Signing&lt;/strong&gt;: The Store version is digitally signed by Microsoft. This eliminates the &quot;Unknown Publisher&quot; warnings and those pesky &lt;code&gt;Wacatac&lt;/code&gt; AI-based false positives.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hassle-Free Updates&lt;/strong&gt;: The Microsoft Store handles all future updates automatically in the background. You’ll always have the latest features and bug fixes without manual downloads.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Security Status Update&lt;/h1&gt;
&lt;p&gt;We are also proud to share that &lt;strong&gt;Microsoft Security Intelligence&lt;/strong&gt; has officially reviewed our application (Submission ID: &lt;code&gt;6a2fc083-8db7-43b6-90d7-6f5bb04d4425&lt;/code&gt;). Their analysts confirmed that MouseMacros contains &lt;strong&gt;no malicious code&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This &quot;clean&quot; determination, combined with our Store presence, provides the highest level of assurance for our users.&lt;/p&gt;
&lt;h2&gt;Store Edition vs. Standalone Version&lt;/h2&gt;
&lt;p&gt;I remain committed to the open-source spirit and will continue to provide standalone versions on &lt;strong&gt;GitHub&lt;/strong&gt; and &lt;strong&gt;SourceForge&lt;/strong&gt;. Here is a quick comparison to help you choose:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Feature&lt;/th&gt;
&lt;th&gt;Store Edition (MSIX)&lt;/th&gt;
&lt;th&gt;Standalone (EXE/MSI)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Source&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Microsoft Store&lt;/td&gt;
&lt;td&gt;GitHub / SourceForge&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Installation&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;One-click / Integrated&lt;/td&gt;
&lt;td&gt;Manual Download&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Updates&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Automatic&lt;/td&gt;
&lt;td&gt;Manual Check&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Digital Signature&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Signed by Microsoft&lt;/td&gt;
&lt;td&gt;In Progress (SignPath)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Portability&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Installed in System&lt;/td&gt;
&lt;td&gt;Portable EXE available&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;What&apos;s Next?&lt;/h2&gt;
&lt;p&gt;While the Microsoft Store handles our &quot;official&quot; distribution, I am currently working with the &lt;strong&gt;SignPath Foundation&lt;/strong&gt; to bring commercial-grade digital signatures to our open-source binaries. My goal is to ensure that no matter where you download MouseMacros, your system treats it with the respect and trust it deserves.&lt;/p&gt;
&lt;h2&gt;Thank You&lt;/h2&gt;
&lt;p&gt;This project started from a personal need to optimize workflows. Seeing it grow from a small script to an officially published Windows application has been an incredible journey.&lt;/p&gt;
&lt;p&gt;Thank you for your continued support, feedback, and patience.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Get MouseMacros on the Microsoft Store:&lt;/strong&gt;
&lt;a href=&quot;https://apps.microsoft.com/detail/9mx3kfbkmn1h&quot;&gt;https://apps.microsoft.com/detail/9mx3kfbkmn1h&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Join our community on &lt;strong&gt;Discord&lt;/strong&gt; for support and feedback: &lt;a href=&quot;https://discord.gg/gZPDdWzrWa&quot;&gt;Samera2022&apos;s Channel&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>MouseMacros Now Available on the SourceForge</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-availableonsf/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-availableonsf/</guid><description>Expanding our horizons - MouseMacros is now mirrored on SourceForge for better accessibility.</description><pubDate>Fri, 30 Jan 2026 15:38:00 GMT</pubDate><content:encoded>&lt;p&gt;As &lt;strong&gt;MouseMacros&lt;/strong&gt; continues to grow, I want to ensure that every user can access our binaries through their preferred platform. Today, I am happy to announce that the project is now officially mirrored on &lt;strong&gt;SourceForge&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;You can visit our new project page here:
&lt;a href=&quot;https://sourceforge.net/projects/mousemacros/&quot;&gt;https://sourceforge.net/projects/mousemacros/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Why SourceForge?&lt;/h3&gt;
&lt;p&gt;While &lt;strong&gt;GitHub&lt;/strong&gt; remains our primary home for source code and development, SourceForge offers several unique advantages for a project like ours:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Global Mirror Network&lt;/strong&gt;: SourceForge provides a robust network of mirrors worldwide, ensuring fast and reliable downloads regardless of your geographic location.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Open Source Tradition&lt;/strong&gt;: SourceForge has been a cornerstone of the open-source community for decades. Hosting MouseMacros here allows us to reach a broader audience of &quot;Advanced End Users&quot; who value established open-source platforms.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Detailed Analytics&lt;/strong&gt;: The platform provides excellent download statistics, which helps me better understand our user base and prioritize future feature updates.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;What This Means for You&lt;/h3&gt;
&lt;p&gt;From now on, every stable release of MouseMacros (including the latest v1.2.x series) will be uploaded to both GitHub and SourceForge simultaneously.&lt;/p&gt;
&lt;p&gt;For our users, this simply means &lt;strong&gt;more choices&lt;/strong&gt;. Whether you prefer the developer-centric environment of GitHub or the classic software directory feel of SourceForge, the binaries you receive will be identical.&lt;/p&gt;
&lt;h3&gt;Stay Connected&lt;/h3&gt;
&lt;p&gt;As always, the project remains fully open-source under the &lt;strong&gt;GPL-3.0 License&lt;/strong&gt;. If you enjoy using the software, consider leaving a review on SourceForge or a Star on GitHub!&lt;/p&gt;
&lt;p&gt;If you have any questions or feedback, feel free to join our &lt;strong&gt;Discord&lt;/strong&gt; community: &lt;a href=&quot;https://discord.gg/gZPDdWzrWa&quot;&gt;Samera2022&apos;s Channel&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Happy Automating!&lt;/p&gt;
</content:encoded></item><item><title>MouseMacros-1.2.3 Release</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-123-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-123-release/</guid><description>MouseMacros Updates</description><pubDate>Fri, 30 Jan 2026 08:33:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-30 16:33] 1.2.3 &lt;a href=&quot;https://www.github.com/Samera2022/MouseMacros/releases/tag/1.2.3&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Fixed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;修改并补全部分语言的语言文件。&lt;/li&gt;
&lt;li&gt;微调ExitDialog的高度补全参数。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>L1-036~L1-040的笔记</title><link>https://samera2022.github.io/posts/notes/gplt/l1-036l1-040/</link><guid isPermaLink="true">https://samera2022.github.io/posts/notes/gplt/l1-036l1-040/</guid><description>GPLT的笔记</description><pubDate>Sat, 24 Jan 2026 01:42:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/GPLTNotes&quot;}&lt;/p&gt;
&lt;p&gt;P.S. 这份笔记同步发布在我的博客上，建议在博客中查看以享受完整的MD Extended Features. 你可以点此&lt;a href=&quot;https://samera2022.github.io/posts/Notes/GPLT/l1-036l1-040/&quot;&gt;快速跳转&lt;/a&gt;到相应页面，我的博客地址为https://samera2022.github.io&lt;/p&gt;
&lt;h1&gt;L1-036&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int A,B;
    cin&amp;gt;&amp;gt;A&amp;gt;&amp;gt;B;
    cout&amp;lt;&amp;lt;A*B;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有什么好记的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-037&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;
//spec A 2/10

int gcd(int a, int b) {
    while (b != 0) {
        a %= b;
        swap(a, b);
    }
    return a;
}

void solve(int A, int B) {
    cout&amp;lt;&amp;lt;A&amp;lt;&amp;lt;&quot;/&quot;&amp;lt;&amp;lt;(B&amp;gt;=0?to_string(B):(&quot;(&quot;+to_string(B)+&quot;)&quot;))&amp;lt;&amp;lt;&quot;=&quot;;
    if (B==0) {
        cout&amp;lt;&amp;lt;&quot;Error&quot;;
        return;
    }
    const int multiplier = gcd(abs(A),abs(B));
    A /= multiplier;
    B /= multiplier;
    cout&amp;lt;&amp;lt;fixed&amp;lt;&amp;lt;setprecision(2)&amp;lt;&amp;lt;static_cast&amp;lt;double&amp;gt;(A)/B;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int A, B;
    cin&amp;gt;&amp;gt;A&amp;gt;&amp;gt;B;
    solve(A,B);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt;也可以进行格式输出。本段代码所示的为保留两位小数输出，写法为&lt;code&gt;cout&amp;lt;&amp;lt;fixed&amp;lt;&amp;lt;setprecision(2)&amp;lt;&amp;lt;...&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;除此之外地，它支持填充字符（&lt;code&gt;123-&amp;gt;*****123&lt;/code&gt;），写法为&lt;code&gt;cout&amp;lt;&amp;lt;setw(int)&amp;lt;&amp;lt;setfill(char)&amp;lt;&amp;lt;...&lt;/code&gt;; 进制转换（&lt;code&gt;255-&amp;gt;0xff&lt;/code&gt;），写法为&lt;code&gt;cout&amp;lt;&amp;lt;showbase&amp;lt;&amp;lt;hex&amp;lt;&amp;lt;...&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;特别地，&lt;code&gt;setw(n)&lt;/code&gt;仅对下次输出有效，其他操作符都是全局生效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-038&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cout&amp;lt;&amp;lt;&quot;Hello World\nHello New World&quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有什么好记的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-039&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

void complete(const int N, string&amp;amp; s) {
    const int len = static_cast&amp;lt;int&amp;gt;(s.length());
    const int time = N - len % N;
    for (int i = 1; i &amp;lt;= time; i++) s.append(&quot; &quot;);
}

void solve(const int N, string&amp;amp; s) {
    const int len = static_cast&amp;lt;int&amp;gt;(s.length());
    const int col = ((len%N==0) ? 0 : 1 ) + len / N;
    complete(N,s);
    for (int i = 1; i &amp;lt;= N; i++)
        for (int j = col - 1; j &amp;gt;= 0; j--)
            cout&amp;lt;&amp;lt;s[j * N + i - 1]&amp;lt;&amp;lt;((j==0)?&quot;\n&quot;:&quot;&quot;);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    string s;
    cin&amp;gt;&amp;gt;N;
    cin.ignore();
    getline(cin,s);
    solve(N,s);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;本题需要找一下规律，发现第一行均为&lt;code&gt;len%N==1&lt;/code&gt;，第二行均为&lt;code&gt;len%N==2&lt;/code&gt;，以此类推，在补空格使得字符串能被N整除之后，根据先前的规律反推即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-040&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin &amp;gt;&amp;gt; N;
    for (int i = 1; i &amp;lt;= N; i++) {
        char gender;
        double height;
        cin &amp;gt;&amp;gt; gender &amp;gt;&amp;gt; height;
        cout&amp;lt;&amp;lt;fixed&amp;lt;&amp;lt;setprecision(2)&amp;lt;&amp;lt;(gender==&apos;M&apos;?height/1.09:height*1.09)&amp;lt;&amp;lt;&quot;\n&quot;;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有什么好记的。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>L1-031~L1-035的笔记</title><link>https://samera2022.github.io/posts/notes/gplt/l1-031l1-035/</link><guid isPermaLink="true">https://samera2022.github.io/posts/notes/gplt/l1-031l1-035/</guid><description>GPLT的笔记</description><pubDate>Sat, 24 Jan 2026 01:25:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/GPLTNotes&quot;}&lt;/p&gt;
&lt;p&gt;P.S. 这份笔记同步发布在我的博客上，建议在博客中查看以享受完整的MD Extended Features. 你可以点此&lt;a href=&quot;https://samera2022.github.io/posts/Notes/GPLT/l1-031l1-035/&quot;&gt;快速跳转&lt;/a&gt;到相应页面，我的博客地址为https://samera2022.github.io&lt;/p&gt;
&lt;h1&gt;L1-031&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;
//spec A 9/10

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin&amp;gt;&amp;gt;N;
    for (int i = 1; i &amp;lt;= N; i++) {
        int H;
        cin&amp;gt;&amp;gt;H;
        int W;
        cin&amp;gt;&amp;gt;W;
        const double sW = (H-100) * 0.9 * 2;
        const double delta = abs(W-sW);
        if (delta&amp;lt;0.1*sW) cout&amp;lt;&amp;lt;&quot;You are wan mei!\n&quot;;
        else if (sW&amp;gt;=W) cout&amp;lt;&amp;lt;&quot;You are tai shou le!\n&quot;;
        else if (sW&amp;lt;=W) cout&amp;lt;&amp;lt;&quot;You are tai pang le!\n&quot;;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;采用&lt;code&gt;if else-if&lt;/code&gt;的写法能够更加准确地进行判断。如果在&lt;code&gt;else-if&lt;/code&gt;中仍然采用&lt;code&gt;1.1*sW&amp;lt;=W&lt;/code&gt;和&lt;code&gt;0.9*sW&amp;gt;=W&lt;/code&gt;的写法，很容易因为精度误差而发生错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-032&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    char delimiter;
    cin&amp;gt;&amp;gt;N&amp;gt;&amp;gt;delimiter;
    string content;
    cin.ignore();
    getline(cin,content);
    if (const int len = static_cast&amp;lt;int&amp;gt;(content.length()); N&amp;gt;=len) {
        for (int i = 1; i &amp;lt;= N-len; i++) cout&amp;lt;&amp;lt;string(1,delimiter);
        cout&amp;lt;&amp;lt;content;
    } else cout&amp;lt;&amp;lt;content.substr(len-N,N);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;此处是&lt;code&gt;getline()&lt;/code&gt;的第二种用法，即读取输入的整行内容到给定的字符串中。有的时候输入的数据中含有空格，却仍然要求读取整行时便会使用这种写法。特别地，由于&lt;code&gt;cin&lt;/code&gt;读掉内容之后仍然会留下换行符或者空格，因此如果和&lt;code&gt;cin&lt;/code&gt;连用，需要再次使用&lt;code&gt;cin.ignore()&lt;/code&gt;或&lt;code&gt;ws(cin)&lt;/code&gt;忽略这些空白字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-033&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

void complete(string&amp;amp; y);
int getTimes(const string &amp;amp;y);
void add(string&amp;amp; y);

set&amp;lt;char&amp;gt; temp;
int times;
int len;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    string y;
    int n;
    cin&amp;gt;&amp;gt;y&amp;gt;&amp;gt;n;
    complete(y);
    while (getTimes(y)!=n) add(y);
    cout&amp;lt;&amp;lt;times&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;y;
    return 0;
}

void complete(string&amp;amp; y) {
    len = static_cast&amp;lt;int&amp;gt;(y.length());
    for (int i = 1; i &amp;lt;= 4-len; i++) y.insert(0,&quot;0&quot;);
}

int getTimes(const string&amp;amp; y) {
    len = static_cast&amp;lt;int&amp;gt;(y.length());
    for (int i = 1; i &amp;lt;= len; i++) temp.insert(y[i-1]);
    const int time = static_cast&amp;lt;int&amp;gt;(temp.size());
    temp.clear();
    return time;
}

void add(string&amp;amp; y) {
    times++;
    int time = stoi(y);
    time++;
    y = to_string(time);
    complete(y);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这种方法看起来比较臃肿，但是我暂时也没想到更好的方法））&lt;/li&gt;
&lt;li&gt;C++中在&lt;code&gt;string&lt;/code&gt;的末端添加内容一般使用&lt;code&gt;string.append()&lt;/code&gt;方法，而在前端添加内容则需要使用&lt;code&gt;string.insert(0,content)&lt;/code&gt;方法。特别地，&lt;code&gt;insert()&lt;/code&gt;方法本身是用来在某位置插入某内容的，在此处因为目标在开头所以填入索引为0。&lt;/li&gt;
&lt;li&gt;清空&lt;code&gt;set&lt;/code&gt;中所有元素的方法为&lt;code&gt;set.clear()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-034&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

map&amp;lt;int,int&amp;gt; tagMap;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int times;
    cin&amp;gt;&amp;gt;times;
    for (int i = 1; i &amp;lt;= times; i++) {
        int time;
        cin&amp;gt;&amp;gt;time;
        for (int j = 1; j &amp;lt;= time; j++) {
            int tag;
            cin&amp;gt;&amp;gt;tag;
            tagMap[tag]++;
        }
    }
    int keyM = 0;
    int valM = 0;
    for (auto const&amp;amp; [key, val]: tagMap) {
        if (val&amp;gt;valM) {
            keyM = key;
            valM = val;
        } else if (val==valM) {
            if (key&amp;gt;keyM) {
                keyM = key;
                valM = val;
            }
        }
    }
    cout&amp;lt;&amp;lt;keyM&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;valM;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;本段代码中使用的是&lt;code&gt;结构化绑定&lt;/code&gt;遍历，这种遍历要求类型必须为&lt;code&gt;auto&lt;/code&gt;。该写法等价于&lt;code&gt;for (const auto&amp;amp; kv : tagMap) { auto key = kv.first, val = kv.second; }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-035&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int time = 0;
    string i2;
    string i14;
    for (;;) {
        string input;
        cin&amp;gt;&amp;gt;input;
        if (input==&quot;.&quot;) break;
        time++;
        if (time==2) i2 = input;
        if (time==14) i14 = input;
    }
    if (i2.empty()) cout&amp;lt;&amp;lt;&quot;Momo... No one is for you ...&quot;;
    else if (i14.empty()) cout&amp;lt;&amp;lt;i2&amp;lt;&amp;lt;&quot; is the only one for you...&quot;;
    else cout&amp;lt;&amp;lt;i2&amp;lt;&amp;lt;&quot; and &quot;&amp;lt;&amp;lt;i14&amp;lt;&amp;lt;&quot; are inviting you to dinner...&quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有什么好记的。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>L1-026~L1-030的笔记</title><link>https://samera2022.github.io/posts/notes/gplt/l1-026l1-030/</link><guid isPermaLink="true">https://samera2022.github.io/posts/notes/gplt/l1-026l1-030/</guid><description>GPLT的笔记</description><pubDate>Sat, 24 Jan 2026 00:51:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/GPLTNotes&quot;}&lt;/p&gt;
&lt;p&gt;P.S. 这份笔记同步发布在我的博客上，建议在博客中查看以享受完整的MD Extended Features. 你可以点此&lt;a href=&quot;https://samera2022.github.io/posts/Notes/GPLT/l1-026l1-030/&quot;&gt;快速跳转&lt;/a&gt;到相应页面，我的博客地址为https://samera2022.github.io&lt;/p&gt;
&lt;h1&gt;L1-026&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cout&amp;lt;&amp;lt;&quot;I\n \nL\no\nv\ne\n \nG\nP\nL\nT&quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有什么好记的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-027&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

void solve(const string&amp;amp; tel);

int num[10];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    string tel;
    cin&amp;gt;&amp;gt;tel;
    solve(tel);
    return 0;
}

void solve(const string&amp;amp; tel) {
    vector&amp;lt;int&amp;gt; used;
    vector&amp;lt;int&amp;gt; index;
    const int len1 = static_cast&amp;lt;int&amp;gt;(tel.length());
    for (int i = 1; i &amp;lt;= len1; i++) num[tel[i-1]-&apos;0&apos;]++;
    for (int i = 10; i &amp;gt;= 1; i--) if (num[i-1]!=0) used.push_back(i-1);
    cout&amp;lt;&amp;lt;&quot;int[] arr = new int[]{&quot;;
    const int len2 = static_cast&amp;lt;int&amp;gt;(used.size());
    for (int i = 1; i &amp;lt;= len2; i++) cout &amp;lt;&amp;lt; used[i-1] &amp;lt;&amp;lt; (i == len2 ? &quot;&quot; : &quot;,&quot;);
    cout&amp;lt;&amp;lt;&quot;};\n&quot;;
    for (int i = 1; i &amp;lt;= len1; i++) if (auto it = find(used.begin(), used.end(), tel[i-1] - &apos;0&apos;); it != used.end()) index.push_back(static_cast&amp;lt;int&amp;gt;(distance(used.begin(),it)));
    cout&amp;lt;&amp;lt;&quot;int[] index = new int[]{&quot;;
    const int len3 = static_cast&amp;lt;int&amp;gt;(index.size());
    for (int i = 1; i &amp;lt;= len3; i++) cout &amp;lt;&amp;lt; index[i-1] &amp;lt;&amp;lt; (i == len3 ? &quot;&quot; : &quot;,&quot;);
    cout&amp;lt;&amp;lt;&quot;};\n&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    for (int i = 1; i &amp;lt;= len1; i++) 
        if (auto it = find(used.begin(), used.end(), tel[i-1] - &apos;0&apos;); it != used.end()) 
            index.push_back(static_cast&amp;lt;int&amp;gt;(distance(used.begin(),it)));
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;C++数组中查询某元素的索引写法比较独特，要通过&lt;code&gt;iterator&lt;/code&gt;来实现。&lt;code&gt;if (auto it = find(used.begin(), used.end(), tel[i-1] - &apos;0&apos;); it != used.end())&lt;/code&gt;这一句是指从&lt;code&gt;vector&lt;/code&gt;的开始到结束，查找并返回&lt;code&gt;tel[i-1]-&apos;0&apos;&apos;&lt;/code&gt;的位置，且当该位置不为最后时，执行如下操作。 而后通过&lt;code&gt;distance&lt;/code&gt;计算当前迭代器所指的位置和最开始的位置的距离。&lt;/li&gt;
&lt;li&gt;一般地，针对普适的遍历，我们只需要: &lt;code&gt;for (auto it = begin(s); it != end(s); it++)&lt;/code&gt;即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-028&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;
//spec A 4/10

const string&amp;amp; isPrime(ll n);
string YES = &quot;Yes&quot;;
string NO = &quot;No&quot;;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin&amp;gt;&amp;gt;N;
    for (int i = 1; i &amp;lt;= N; i++) {
        int num;
        cin&amp;gt;&amp;gt;num;
        cout&amp;lt;&amp;lt;isPrime(num)&amp;lt;&amp;lt;&quot;\n&quot;;
    }
    return 0;
}

ll llPow(ll a, ll b, const ll mod) {
    ll res = 1;
    a %= mod;
    while (b &amp;gt; 0) {
        if (b % 2 == 1) res = static_cast&amp;lt;ll&amp;gt;(static_cast&amp;lt;__int128_t&amp;gt;(res) * a % mod);;
        a = a * a % mod;
        b /= 2;
    }
    return res;
}

bool mrTest(const ll n, const ll a) {
    if (a % n == 0) return true;
    ll d = n - 1;
    while (d % 2 == 0) d /= 2;
    ll x = llPow(a, d, n);
    if (x == 1 || x == n - 1) return true;
    while (d != n - 1) {
        x = static_cast&amp;lt;ll&amp;gt;(static_cast&amp;lt;__int128_t&amp;gt;(x) * x % n);        d *= 2;
        if (x == n - 1) return true;
        if (x == 1) return false;
    }
    return false;
}


const string&amp;amp; isPrime(const ll n) {
    if (n &amp;lt; 2) return NO;
    if (n == 2 || n == 3) return YES;
    if (n % 2 == 0) return NO;

    static const vector&amp;lt;ll&amp;gt; bases = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};

    for (const ll a : bases) {
        if (n == a) return YES;
        if (!mrTest(n, a)) return NO;
    }
    return YES;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;本题如果用一般的埃氏筛法，可以拿到6分。剩下的4分需要使用更高效的质数算法：Miller-Rabin素数测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-029&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int H;
    cin&amp;gt;&amp;gt;H;
    printf(&quot;%.1f&quot;,(H-100)*0.9*2);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有什么好记的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-030&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin&amp;gt;&amp;gt;N;
    string girls[N/2];
    string boys[N/2];
    string index;
    int curtG = 1;
    int curtB = 1;
    for (int i = 1; i &amp;lt;= N; i++) {
        int gender;
        cin&amp;gt;&amp;gt;gender;
        string name;
        cin&amp;gt;&amp;gt;name;
        if (!gender) {
            girls[curtG-1] = name;
            curtG++;
        } else {
            boys[curtB-1] = name;
            curtB++;
        }
        if (i&amp;lt;=N/2) index.append(to_string(gender));
    }
    curtG = 1;
    curtB = 1;
    for (int i = 1; i &amp;lt;= N/2; i++) {
        if (const int gender = index[i-1]-&apos;0&apos;; !gender) {
            cout&amp;lt;&amp;lt;girls[curtG-1]&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;boys[N/2-curtG]&amp;lt;&amp;lt;&quot;\n&quot;;
            curtG++;
        } else {
            cout&amp;lt;&amp;lt;boys[curtB-1]&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;girls[N/2-curtB]&amp;lt;&amp;lt;&quot;\n&quot;;
            curtB++;
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有什么好记的。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>L1-021~L1-025的笔记</title><link>https://samera2022.github.io/posts/notes/gplt/l1-021l1-025/</link><guid isPermaLink="true">https://samera2022.github.io/posts/notes/gplt/l1-021l1-025/</guid><description>GPLT的笔记</description><pubDate>Fri, 23 Jan 2026 03:06:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/GPLTNotes&quot;}&lt;/p&gt;
&lt;p&gt;P.S. 这份笔记同步发布在我的博客上，建议在博客中查看以享受完整的MD Extended Features. 你可以点此&lt;a href=&quot;https://samera2022.github.io/posts/Notes/GPLT/l1-021l1-025/&quot;&gt;快速跳转&lt;/a&gt;到相应页面，我的博客地址为https://samera2022.github.io&lt;/p&gt;
&lt;h1&gt;L1-021&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cout&amp;lt;&amp;lt;&quot;I&apos;m gonna WIN!\n&quot;;
    cout&amp;lt;&amp;lt;&quot;I&apos;m gonna WIN!\n&quot;;
    cout&amp;lt;&amp;lt;&quot;I&apos;m gonna WIN!\n&quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有什么好记的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-022&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin&amp;gt;&amp;gt;N;
    int oddNum = 0;
    for (int i = 1; i &amp;lt;= N; i++) {
        int temp;
        cin&amp;gt;&amp;gt;temp;
        if (temp%2==1) oddNum++;
    }
    cout&amp;lt;&amp;lt;oddNum&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;N-oddNum;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有什么好记的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-023&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int g, p ,l ,t;
    g=p=l=t=0;
    string input;
    cin&amp;gt;&amp;gt;input;
    const int len = static_cast&amp;lt;int&amp;gt;(input.length());
    for (int i = 1; i &amp;lt;= len; i++) {
        switch (input[i-1]) {
            case &apos;g&apos;:
            case &apos;G&apos;:
                g++;
                break;
            case &apos;p&apos;:
            case &apos;P&apos;:
                p++;
                break;
            case &apos;l&apos;:
            case &apos;L&apos;:
                l++;
                break;
            case &apos;t&apos;:
            case &apos;T&apos;:
                t++;
                break;
            default:
                break;
        }
    }
    while (g!=0||p!=0||l!=0||t!=0) {
        if (g!=0) {
            cout&amp;lt;&amp;lt;&quot;G&quot;;
            g--;
        }
        if (p!=0) {
            cout&amp;lt;&amp;lt;&quot;P&quot;;
            p--;
        }
        if (l!=0) {
            cout&amp;lt;&amp;lt;&quot;L&quot;;
            l--;
        }
        if (t!=0) {
            cout&amp;lt;&amp;lt;&quot;T&quot;;
            t--;
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有什么好记的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-024&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int num[] = {3,4,5,6,7,1,2};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int D;
    cin&amp;gt;&amp;gt;D;
    cout&amp;lt;&amp;lt;num[D-1];
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有什么好记的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-025&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;
//spec 1/15

int formatString(const string &amp;amp;a);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    string a,b,c;
    cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;
    const int numA = formatString(a);
    int numB;
    if (c.empty()) numB = formatString(b);
    else numB = -1;
    cout&amp;lt;&amp;lt;(numA==-1?&quot;?&quot;:to_string(numA))&amp;lt;&amp;lt;&quot; + &quot;&amp;lt;&amp;lt;(numB==-1?&quot;?&quot;:to_string(numB))&amp;lt;&amp;lt;&quot; = &quot;&amp;lt;&amp;lt;((numA==-1||numB==-1)?&quot;?&quot;:to_string(numA+numB));
    return 0;
}

int formatString(const string &amp;amp;a) {
    if (const int aLen = static_cast&amp;lt;int&amp;gt;(a.length()); aLen==4&amp;amp;&amp;amp;a==&quot;1000&quot;) return 1000;
    else if (aLen&amp;lt;4&amp;amp;&amp;amp;a!=&quot;0&quot;)
        for (int i = 1; i &amp;lt;= aLen; i++) {
            if (!isdigit(a[i-1])) return -1;
        }
    else return -1;
    return stoi(a);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;【再次强调】C++中&lt;code&gt;char&lt;/code&gt;转&lt;code&gt;String&lt;/code&gt;不能使用&lt;code&gt;to_string(char)&lt;/code&gt;。如果已经确定&lt;code&gt;char&lt;/code&gt;为数字，则可用&lt;code&gt;char - &apos;0&apos;&lt;/code&gt;转为&lt;code&gt;int&lt;/code&gt;类型，而后使用&lt;code&gt;to_string(int)&lt;/code&gt;，即&lt;code&gt;to_string(char-&apos;0&apos;)&lt;/code&gt;。如果&lt;code&gt;char&lt;/code&gt;未被确定类型（数字也可以），则直接使用&lt;code&gt;string(1,char)&lt;/code&gt;即可。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>L1-016~L1-020的笔记</title><link>https://samera2022.github.io/posts/notes/gplt/l1-016l1-020/</link><guid isPermaLink="true">https://samera2022.github.io/posts/notes/gplt/l1-016l1-020/</guid><description>GPLT的笔记</description><pubDate>Thu, 22 Jan 2026 13:03:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/GPLTNotes&quot;}&lt;/p&gt;
&lt;p&gt;P.S. 这份笔记同步发布在我的博客上，建议在博客中查看以享受完整的MD Extended Features. 你可以点此&lt;a href=&quot;https://samera2022.github.io/posts/Notes/GPLT/l1-016l1-020/&quot;&gt;快速跳转&lt;/a&gt;到相应页面，我的博客地址为https://samera2022.github.io&lt;/p&gt;
&lt;h1&gt;L1-016&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;
//spec A

void solve(const string s[], int size);

int weight[] = {7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
char validate[] = &quot;10X98765432&quot;;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin&amp;gt;&amp;gt;N;
    string s[N];
    for (int i = 1; i &amp;lt;= N; i++) {
        string content;
        cin&amp;gt;&amp;gt;content;
        s[i-1] = content;
    }
    solve(s, N);
    return 0;
}

void solve(const string s[], const int size) {
    int errors = 0;
    vector&amp;lt;string_view&amp;gt; vsv;
    for (int i = 1; i &amp;lt;= size; i++) {
        const string &amp;amp;content = s[i-1];
        int temp = 0;
        bool isDigit = true;
        for (int j = 1; j &amp;lt;= 17; j++) {
            if (isdigit(content[j-1]))  temp += (content[j-1]-&apos;0&apos;) * weight[j-1];
            else {
                isDigit = false;
                break;
            }
        }
        if (validate[temp%11]!=content[17] || !isDigit) {
            errors++;
            vsv.push_back(content);
        }
    }
    if (vsv.empty()) cout&amp;lt;&amp;lt;&quot;All passed&quot;;
    else for (const string_view sv : vsv) cout&amp;lt;&amp;lt;sv&amp;lt;&amp;lt;&quot;\n&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;string s[]&lt;/code&gt;仅在其定义域中能够获取其大小。获取大小的方式有如下两种：①&lt;code&gt;sizeof(s)/sizeof(s[0])&lt;/code&gt;通过整个数组占用的字节数除以单个元素占用的字节数; ②&lt;code&gt;begin(s)-end(s)&lt;/code&gt;通过指针相减来计算元素个数。说实在话，这两种不如直接使用定义&lt;code&gt;string s[]&lt;/code&gt;长度的变量了。&lt;/li&gt;
&lt;li&gt;需要注意的是: ①&lt;code&gt;s-&amp;gt;length();&lt;/code&gt;和&lt;code&gt;s-&amp;gt;size();&lt;/code&gt;获取的不是&lt;code&gt;s[]&lt;/code&gt;的大小，而是&lt;code&gt;s[0]&lt;/code&gt;的长度; ②将数组&lt;code&gt;s[]&lt;/code&gt;作为参数传入函数后，其会发生&lt;code&gt;指针退化&lt;/code&gt;，即&lt;code&gt;数组丢失了其长度信息和数组类型属性，隐式地转换成指向其第一个元素的指针&lt;/code&gt;。这导致无法在传入的函数中正确获取其长度。&lt;/li&gt;
&lt;li&gt;向&lt;code&gt;vector&lt;/code&gt;中压入数据使用的是&lt;code&gt;vector.push_back()&lt;/code&gt;，这会将新的元素放在队尾。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string_view&lt;/code&gt;是保存&lt;code&gt;string&lt;/code&gt;的引用的一个容器，&lt;code&gt;cout&lt;/code&gt;方法有对其的兼容。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    for (int i = 1; i &amp;lt;= N; i++) {
        string content;
        cin&amp;gt;&amp;gt;content;
        s[i-1] = content;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;针对这一段循环输入，有以下几种简洁的替代方案:&lt;/li&gt;
&lt;li&gt;①（定长数组或vector）&lt;code&gt;for (string&amp;amp; content : s) cin &amp;gt;&amp;gt; content;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;②（定长数组或vector）&lt;code&gt;copy_n(istream_iterator&amp;lt;string&amp;gt;(cin), N, (定长数组) s | (vector) s.begin());&lt;/code&gt; 需要补充的是: &lt;code&gt;(定长数组) s&lt;/code&gt;这里的&lt;code&gt;s&lt;/code&gt;是以&lt;code&gt;指向首元素的指针（迭代器）&lt;/code&gt;传入的。&lt;/li&gt;
&lt;li&gt;③（vector）&lt;code&gt;vector&amp;lt;string&amp;gt; s{istream_iterator&amp;lt;string&amp;gt;(cin), istream_iterator&amp;lt;string&amp;gt;()};&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;④（vector）重载位右移运算符&lt;code&gt;istream&amp;amp; operator&amp;gt;&amp;gt;(istream&amp;amp; is, vector&amp;lt;T&amp;gt;&amp;amp; v) { for (auto&amp;amp; x : v) is &amp;gt;&amp;gt; x; return is;}&lt;/code&gt;而后&lt;code&gt;vector&amp;lt;string&amp;gt; s(N); cin &amp;gt;&amp;gt; s;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-017&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

void solve(string&amp;amp; content);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    string content;
    cin&amp;gt;&amp;gt;content;
    solve(content);
    return 0;
}

void solve(string&amp;amp; content) {
    bool isNegative = false;
    if (!isdigit(content[0])) {
        content.erase(remove(content.begin(),content.end(),&apos;-&apos;),content.end());
        isNegative = true;
    }
    int cnt = 0;
    const int len = static_cast&amp;lt;int&amp;gt;(content.length());
    const bool isEven = (content[len-1]-&apos;0&apos;)%2==0;
    for (int i = 1; i &amp;lt;= len; i++) if (content[i-1]==&apos;2&apos;) cnt++;
    double res = static_cast&amp;lt;double&amp;gt;(cnt)/len;
    if (isNegative) res *= 1.5;
    if (isEven) res *= 2;
    res *= 100;
    printf(&quot;%.2f%%&quot;, res);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;printf()&lt;/code&gt;是格式化输出，前面的&lt;code&gt;%.2f&lt;/code&gt;指的是以两位小数输出，后面的&lt;code&gt;%%&lt;/code&gt;指的是输出一个%符号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printf()&lt;/code&gt;支持以下几种格式说明符: &lt;code&gt;%d&lt;/code&gt;(有符号十进制整数) &lt;code&gt;%f&lt;/code&gt;(浮点数) &lt;code&gt;%s&lt;/code&gt;(字符串) &lt;code&gt;%c&lt;/code&gt;(字符) &lt;code&gt;%x&lt;/code&gt;(无符号十六进制整数)。&lt;/li&gt;
&lt;li&gt;类似的格式说明符也可以用于输入&lt;code&gt;scanf()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;C++17中检测&lt;code&gt;string&lt;/code&gt;中是否含有某字符需要通过&lt;code&gt;string.find()&lt;/code&gt;来完成。具体地，应为&lt;code&gt;s.find()!=string::npo&lt;/code&gt;，表示找到的位置不是&lt;code&gt;npos&lt;/code&gt;，即该位置存在。可以通过该方法来查询&lt;code&gt;string&lt;/code&gt;中是否出现了负号来判断是否为负数。当然，在本段代码中采用的是&lt;code&gt;isdigit(content[0])&lt;/code&gt;来判断是否有负号。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-018&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

void solve(const string&amp;amp; content);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    string time;
    cin&amp;gt;&amp;gt;time;
    solve(time);
    return 0;
}

void solve(const string&amp;amp; content) {
    const string a = content.substr(0,2);
    const string b = content.substr(3,2);
    const int h = stoi(a);
    if (h&amp;lt;12||(h==12&amp;amp;&amp;amp;b==&quot;00&quot;)) cout&amp;lt;&amp;lt;&quot;Only &quot;&amp;lt;&amp;lt;content&amp;lt;&amp;lt;&quot;.  Too early to Dang.&quot;;
    else {
        const int time = stoi(a)-12+(b==&quot;00&quot;?0:1);
        for (int i = 1; i &amp;lt;= time; i++) cout&amp;lt;&amp;lt;&quot;Dang&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stoi()&lt;/code&gt;只能用于&lt;code&gt;string&lt;/code&gt;转&lt;code&gt;int&lt;/code&gt;的情况。&lt;/li&gt;
&lt;li&gt;【便于记忆】索引是位于字符串中的&lt;code&gt;char&lt;/code&gt;之间的。比方说，以&lt;code&gt;string s = &quot;time&quot;&lt;/code&gt;为例，其索引为&lt;code&gt;0t 1i 2m 3e&lt;/code&gt;。其中，&lt;code&gt;从0开始长度为2&lt;/code&gt;即代表&lt;code&gt;0 1 2&lt;/code&gt;中的&lt;code&gt;char&lt;/code&gt;，即为&lt;code&gt;ti&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-019&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int AMax, BMax, time;
    cin&amp;gt;&amp;gt;AMax&amp;gt;&amp;gt;BMax&amp;gt;&amp;gt;time;
    int curtA = 0, curtB = 0;
    for (int i = 1; i &amp;lt;= time; i++) {
        int num[4];
        cin &amp;gt;&amp;gt; num[0] &amp;gt;&amp;gt; num[1] &amp;gt;&amp;gt; num[2] &amp;gt;&amp;gt; num[3];
        const int sum = num[0] + num[2];
        if (num[1]==sum&amp;amp;&amp;amp;num[3]!=sum) curtA++;
        if (num[1]!=sum&amp;amp;&amp;amp;num[3]==sum) curtB++;
        bool isADefeated = curtA == AMax + 1;
        if (isADefeated || curtB == BMax + 1) {
            cout&amp;lt;&amp;lt;(isADefeated?&quot;A&quot;:&quot;B&quot;)&amp;lt;&amp;lt;&quot;\n&quot;&amp;lt;&amp;lt;(isADefeated?curtB:curtA);
            return 0;
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这里出现了连续定义的两种形式: ①未初始化的定义&lt;code&gt;int AMax, BMax, time;&lt;/code&gt;，此处三个值均未被初始化; ②初始化的定义&lt;code&gt;int curtA = 0, curt B = 0;&lt;/code&gt;，此处两个值均被初始化为0。&lt;/li&gt;
&lt;li&gt;特别地，考虑以下的情况: ①&lt;code&gt;int&amp;amp; a,b;&lt;/code&gt;这种情况应为&lt;code&gt;int &amp;amp;a; int b;&lt;/code&gt;; ②&lt;code&gt;int a,b = 1;&lt;/code&gt;这种情况应为`int a; int b = 1;。&lt;/li&gt;
&lt;li&gt;为处理上一条中的②，我们可以采用C++的链式赋值，即你可以这么操作&lt;code&gt;a=b=1&lt;/code&gt;。具体地，在链式赋值中，编译器首先会从最右端开始分组。计算&lt;code&gt;(b=1)&lt;/code&gt;后返回&lt;code&gt;b&lt;/code&gt;的引用，进而让&lt;code&gt;a= (b=1)&lt;/code&gt;，使得&lt;code&gt;a=1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cin&lt;/code&gt;可连续赋值，如&lt;code&gt;cin &amp;gt;&amp;gt; num[0] &amp;gt;&amp;gt; num[1] &amp;gt;&amp;gt; num[2] &amp;gt;&amp;gt; num[3];&lt;/code&gt;所示。不过这一点在&lt;code&gt;cout&lt;/code&gt;中其实已经用到过了，如之前的&lt;code&gt;cout&amp;lt;&amp;lt;&quot;Only &quot;&amp;lt;&amp;lt;content&amp;lt;&amp;lt;&quot;.  Too early to Dang.&quot;&lt;/code&gt;就是连续传入给&lt;code&gt;cout&lt;/code&gt;的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-020&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin&amp;gt;&amp;gt;N;
    set&amp;lt;string&amp;gt; s;
    for (int i = 1; i &amp;lt;= N; i++) {
        int K;
        cin&amp;gt;&amp;gt;K;
        for (int j = 1; j &amp;lt;= K; j++) {
            string temp;
            cin&amp;gt;&amp;gt;temp;
            if (K&amp;gt;1)
                s.insert(temp);
        }
    }
    int M;
    cin&amp;gt;&amp;gt;M;
    set&amp;lt;string&amp;gt; res;
    bool isFirst = false;
    for (int i = 1; i &amp;lt;= M; i++) {
        string M1;
        cin&amp;gt;&amp;gt;M1;
        if ((s.count(M1)==0)&amp;amp;&amp;amp;res.count(M1)==0) {
            if (isFirst)
                cout&amp;lt;&amp;lt;&quot; &quot;;
            isFirst = true;
            cout&amp;lt;&amp;lt;M1;
            res.insert(M1);
        }
    }
    if (res.empty()) cout&amp;lt;&amp;lt;&quot;No one is handsome&quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++中的&lt;code&gt;set&lt;/code&gt;也要求不能出现重复元素，但&lt;code&gt;multiset&lt;/code&gt;可以出现重复元素。将元素加入&lt;code&gt;set&lt;/code&gt;的方法为&lt;code&gt;set.insert()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;C++17中没有直接检测&lt;code&gt;set&lt;/code&gt;中是否存在某元素的方法，只能通过&lt;code&gt;set.count()&lt;/code&gt;检查元素出现的次数来曲线救国。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>基于偏移截断法的n舍n+1入简单数学分析</title><link>https://samera2022.github.io/posts/experiences/%E5%9F%BA%E4%BA%8E%E5%81%8F%E7%A7%BB%E6%88%AA%E6%96%AD%E6%B3%95%E7%9A%84n%E8%88%8Dn1%E5%85%A5%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/</link><guid isPermaLink="true">https://samera2022.github.io/posts/experiences/%E5%9F%BA%E4%BA%8E%E5%81%8F%E7%A7%BB%E6%88%AA%E6%96%AD%E6%B3%95%E7%9A%84n%E8%88%8Dn1%E5%85%A5%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/</guid><description>讨论C++环境下的偏移截断法</description><pubDate>Thu, 22 Jan 2026 07:08:00 GMT</pubDate><content:encoded>&lt;p&gt;本文主要分析C++环境下的偏移截断法。当然，核心的逻辑对于其他语言也适用，本文仅以C++举例。C++的&lt;code&gt;强制转型&lt;/code&gt;取整为&lt;code&gt;去尾转型&lt;/code&gt;，即抛弃所有小数位数。基于此，我们可以讨论基于偏移的截断。&lt;/p&gt;
&lt;p&gt;本文尽力做到通俗且严谨，如有疏漏还望大佬轻喷，不吝赐教！&lt;/p&gt;
&lt;h1&gt;一、简单解答&lt;/h1&gt;
&lt;h2&gt;法1. 四舍五入的情况（采用实数的规范小数表示证明）&lt;/h2&gt;
&lt;p&gt;特殊地，我们先考虑四舍五入的情况。&lt;/p&gt;
&lt;h3&gt;(1) 考虑正数情况&lt;/h3&gt;
&lt;p&gt;对于正数&lt;code&gt;A.49&lt;/code&gt;和&lt;code&gt;B.51&lt;/code&gt;我们期望得到&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;(B+1)&lt;/code&gt;。为得到我们的期望，我们需要至多能给&lt;code&gt;A&lt;/code&gt;加&lt;code&gt;0.51&lt;/code&gt;，至少要给&lt;code&gt;B&lt;/code&gt;加&lt;code&gt;0.49&lt;/code&gt;。即，我们至多能给&lt;code&gt;A&lt;/code&gt;加&lt;code&gt;(1-0.49)&lt;/code&gt;，至少要给&lt;code&gt;B&lt;/code&gt;加&lt;code&gt;(1-0.51)&lt;/code&gt;。我们需要加入的偏移量&lt;code&gt;Δ&lt;/code&gt;应满足&lt;code&gt;(1-0.51)&amp;lt;Δ&amp;lt;(1-0.49)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们考虑 $$\forall k\in \mathbb{N}^* $$, $$A.50-10^{-k}&amp;lt;A.50 $$取整为 $$A $$, $$B.50+10^{-k}&amp;gt;B.50 $$取整为 $$B+1 $$. 在这种条件下，我们的Δ应满足 $$1-\left( 0.5+10^{-k} \right) \leq\Delta &amp;lt;1-\left( 0.5-10^{-k} \right) $$.&lt;/p&gt;
&lt;p&gt;至此我们可以选择三种方法:&lt;/p&gt;
&lt;h4&gt;法1.1: 极限的保不等式性质（等价于夹逼定理）&lt;/h4&gt;
&lt;p&gt;由极限的保不等式性质，对左右两侧不等式分别求极限，可得 $$\lim_{k\rightarrow \infty} \left[ 1-\left( 0.5+10^{-k} \right) \right] \leq \Delta $$, $$ \Delta \leq \lim_{k\rightarrow \infty} \left[ 1-\left( 0.5-10^{-k} \right) \right] $$.&lt;/p&gt;
&lt;p&gt;考察两个式子的极限，发现 $$\lim_{k\rightarrow \infty} \left[ 1-\left( 0.5+10^{-k} \right) \right] =\lim_{k\rightarrow \infty} \left[ 1-\left( 0.5-10^{-k} \right) \right] =0.5$$&lt;/p&gt;
&lt;p&gt;则有 $$\Delta=0.5 $$.&lt;/p&gt;
&lt;h4&gt;法1.2: 单调性&lt;/h4&gt;
&lt;p&gt;我们可研究不等式两边的单调性，发现 $$1-\left( 0.5+10^{-k} \right) $$单调递增, $$1-\left( 0.5-10^{-k} \right) $$单调递减。&lt;/p&gt;
&lt;p&gt;考察两个式子的极限，发现 $$\lim_{k\rightarrow \infty} \left[ 1-\left( 0.5+10^{-k} \right) \right] =\lim_{k\rightarrow \infty} \left[ 1-\left( 0.5-10^{-k} \right) \right] =0.5$$&lt;/p&gt;
&lt;p&gt;由于 $$1-\left( 0.5+10^{-k} \right) \leq\Delta &amp;lt;1-\left( 0.5-10^{-k} \right) $$ 对 $$\forall k\in \mathbb{N}^* $$ 成立，则取 $$ k \rightarrow \infty $$, 有 $$0.5=\lim_{k\rightarrow \infty} \left[ 1-\left( 0.5+10^{-k} \right) \right] \leq \Delta \leq \lim_{k\rightarrow \infty} \left[ 1-\left( 0.5-10^{-k} \right) \right] =0.5$$, 则 $$\Delta=0.5 $$.&lt;/p&gt;
&lt;h4&gt;法1.3: 不等式+闭区间套定理&lt;/h4&gt;
&lt;p&gt;为了构造闭区间以满足区间套定理的要求，我们将开区间放缩为闭区间（这是充分的），由此可得 $$1-\left( 0.5+10^{-k} \right) \leq\Delta \leq 1-\left( 0.5-10^{-k} \right) $$&lt;/p&gt;
&lt;p&gt;进而我们可以发现 $$\Delta \in \left[ 1-\left( 0.5+10^{-k} \right) ,1-\left( 0.5-10^{-k} \right) \right] $$.&lt;/p&gt;
&lt;p&gt;记 $$a_n=1-\left( 0.5+10^{-k} \right) , b_n=1-\left( 0.5-10^{-k} \right) $$, 则 $$\left{ \left[ a_k,b_k \right] \right} $$ 满足下列条件:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$$\forall k, \left[ a_{k+1},b_{k+1} \right] \subset \left[ a_k,b_k \right] $$&lt;/li&gt;
&lt;li&gt;$$\lim_{k\rightarrow \infty} \left( b_k-a_k \right) =\lim_{k\rightarrow \infty} \left( 2\times 10^{-k} \right) =0$$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可见 $$\left{ \left[ a_k,b_k \right] \right} _{k=1}^{\infty}$$ 是一个闭区间套.&lt;/p&gt;
&lt;p&gt;由区间套定理, 存在唯一的实数 $$\xi $$, 使得 $$\xi \in \left[ a_k,b_k\right]$$&lt;/p&gt;
&lt;p&gt;考察两个式子的极限，发现 $$\lim_{k\rightarrow \infty} \left[ 1-\left( 0.5+10^{-k} \right) \right] =\lim_{k\rightarrow \infty} \left[ 1-\left( 0.5-10^{-k} \right) \right] =0.5$$&lt;/p&gt;
&lt;p&gt;则有唯一实数 $$\xi=0.5 $$, 即 $$\Delta=0.5 $$.&lt;/p&gt;
&lt;h3&gt;(2) 考虑负数情况&lt;/h3&gt;
&lt;p&gt;对于负数&lt;code&gt;-A.49&lt;/code&gt;和&lt;code&gt;-B.51&lt;/code&gt;我们期望得到&lt;code&gt;-A&lt;/code&gt;和&lt;code&gt;-(B+1)&lt;/code&gt;。直接取&lt;code&gt;C=-(-A.49)=A.49&lt;/code&gt;, &lt;code&gt;D=-(-B.51)=B.51&lt;/code&gt;。则注意到在情况(1)中，我们可得C和D在&lt;code&gt;Δ=0.5&lt;/code&gt;时有结果分别为&lt;code&gt;A&lt;/code&gt;与&lt;code&gt;B+1&lt;/code&gt;。则直接全体取反，可得&lt;code&gt;Δ=-0.5&lt;/code&gt;时，满足四舍五入的要求。&lt;/p&gt;
&lt;h2&gt;法2. 四舍五入的情况（采用ε语言证明）&lt;/h2&gt;
&lt;p&gt;上文我们直观地感受了一下大概的情况，现在我们进行严谨的考虑。&lt;/p&gt;
&lt;h3&gt;(1) 考虑正数情况&lt;/h3&gt;
&lt;p&gt;我们考虑 $$\forall n\in \mathbb{N}^*, \varepsilon&amp;gt;0 $$, $$A.50-\varepsilon&amp;lt;A.50 $$取整为 $$A $$, $$B.50+\varepsilon&amp;gt;B.50 $$取整为 $$B+1 $$. 在这种条件下，我们的Δ应满足 $$1-\left( 0.5+\varepsilon \right) \leq\Delta &amp;lt;1-\left( 0.5-\varepsilon \right) $$, 即 $$0.5-\varepsilon \leq \Delta \leq 0.5+\varepsilon $$.&lt;/p&gt;
&lt;p&gt;至此我们选择下列两种方法:&lt;/p&gt;
&lt;h4&gt;法2.1: 极限的保不等式性质（等价于夹逼定理）&lt;/h4&gt;
&lt;p&gt;由于 $$\forall \varepsilon &amp;gt;0, \text{均有}0.5-\varepsilon \leq \Delta &amp;lt;0.5+\varepsilon $$, 则对不等式两端同取 $$\varepsilon\rightarrow 0 $$ 的极限，则有 $$\lim_{\varepsilon \rightarrow 0^+} \left( 0.5-\varepsilon \right) \leq \Delta \leq \lim_{\varepsilon \rightarrow 0^+} \left( 0.5+\varepsilon \right) $$. 进而有 $$\Delta=0.5 $$&lt;/p&gt;
&lt;h4&gt;法2.2: 不等式引理+反证法&lt;/h4&gt;
&lt;p&gt;先考虑不等式的左侧: $$0.5-\varepsilon \leq \Delta $$.&lt;/p&gt;
&lt;p&gt;根据引理 $$\text{若}\forall \varepsilon &amp;gt;0, \text{均有}a&amp;lt;b+\varepsilon , \text{则}a\le b$$, 有 $$0.5 \leq \Delta $$&lt;/p&gt;
&lt;p&gt;考虑不等式的右侧:  $$\Delta \leq 0.5+\varepsilon$$. 考虑下列命题: $$\forall \varepsilon &amp;gt;0, \text{若}\Delta +\varepsilon &amp;lt;0.5, \text{则}\Delta \leq 0.5 $$&lt;/p&gt;
&lt;p&gt;采用反证法: 假设 $$\Delta &amp;gt;0.5 $$, 则 $$\Delta +\varepsilon &amp;gt;0.5+\varepsilon $$, 与题设 $$\Delta +\varepsilon &amp;lt;0.5$$ 矛盾！故有 $$\Delta \leq 0.5$$ 成立! 再由 $$0.5 \leq \Delta $$, 可得 $$\Delta=0.5 $$.&lt;/p&gt;
&lt;h3&gt;(2) 考虑负数情况&lt;/h3&gt;
&lt;p&gt;考虑 $$\forall \varepsilon&amp;gt;0  $$, 对于负数&lt;code&gt;-A-0.5+ε&lt;/code&gt;和&lt;code&gt;-B-0.5-ε&lt;/code&gt;我们期望得到&lt;code&gt;-A&lt;/code&gt;和&lt;code&gt;-(B+1)&lt;/code&gt;。直接取&lt;code&gt;C=-(-A-0.5+ε)=A+0.5-ε&lt;/code&gt;, &lt;code&gt;D=-(-B-0.5-ε)=B+0.5+ε&lt;/code&gt;。则注意到在情况(1)中，我们可得C和D在&lt;code&gt;Δ=0.5&lt;/code&gt;时有结果分别为A与B+1。则直接全体取反，可得&lt;code&gt;Δ=-0.5&lt;/code&gt;时，满足四舍五入的要求。&lt;/p&gt;
&lt;h2&gt;n舍n+1入的情况&lt;/h2&gt;
&lt;p&gt;上文中我们对四舍五入的情况给出了5种证明方法，此处我们仅使用&lt;code&gt;ε语言证明+极限的保不等式性质（等价于夹逼定理）&lt;/code&gt;证明，其他方法同理。&lt;/p&gt;
&lt;h3&gt;(1) 考虑正数情况&lt;/h3&gt;
&lt;p&gt;我们考虑 $$\forall n\in \mathbb{N}^*, \varepsilon&amp;gt;0 $$, $$A+0.1(n+1)-\varepsilon&amp;lt;A+0.1(n+1) $$取整为 $$A $$, $$B+0.1(n+1)+\varepsilon&amp;gt;B+0.1(n+1) $$取整为 $$B+1 $$. 在这种条件下，我们的Δ应满足 $$1-\left( 0.1(n+1)+\varepsilon \right) \leq\Delta &amp;lt;1-\left( 0.1(n+1)-\varepsilon \right) $$, 即 $$0.9-0.1n-\varepsilon \leq \Delta \leq 0.9-0.1n+\varepsilon $$.&lt;/p&gt;
&lt;p&gt;由于 $$\forall \varepsilon &amp;gt;0, \text{均有}0.9-0.1n-\varepsilon \leq \Delta \leq 0.9-0.1n+\varepsilon $$, 则对不等式两端同取 $$\varepsilon\rightarrow 0 $$ 的极限，则有 $$\lim_{\varepsilon \rightarrow 0^+} \left( 0.9-0.1n-\varepsilon \right) \leq \Delta \leq \lim_{\varepsilon \rightarrow 0^+} \left( 0.9-0.1n+\varepsilon \right) $$. 进而有 $$\Delta=0.9-0.1n $$&lt;/p&gt;
&lt;h3&gt;(2) 考虑负数情况&lt;/h3&gt;
&lt;p&gt;考虑 $$\forall \varepsilon&amp;gt;0  $$, 对于负数&lt;code&gt;-A-0.1(n+1)+ε&lt;/code&gt;和&lt;code&gt;-B-0.1(n+1)-ε&lt;/code&gt;我们期望得到&lt;code&gt;-A&lt;/code&gt;和&lt;code&gt;-(B+1)&lt;/code&gt;。直接取&lt;code&gt;C=-(-A-0.1(n+1)+ε)=A+0.1(n+1)-ε&lt;/code&gt;, &lt;code&gt;D=-(-B-0.1(n+1)-ε)=B+0.1(n+1)+ε&lt;/code&gt;。则注意到在情况(1)中，我们可得&lt;code&gt;C&lt;/code&gt;和&lt;code&gt;D&lt;/code&gt;在&lt;code&gt;Δ=0.9-0.1n&lt;/code&gt;时有结果分别为&lt;code&gt;A&lt;/code&gt;与&lt;code&gt;B+1&lt;/code&gt;。则直接全体取反，可得&lt;code&gt;Δ=-(0.9-0.1n)&lt;/code&gt;时，满足n舍n+1入的要求。&lt;/p&gt;
&lt;h1&gt;二、复杂解答&lt;/h1&gt;
&lt;h2&gt;定义&lt;/h2&gt;
&lt;p&gt;在详细的讨论开始前，我们先进行如下定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义截断算子: $$Tr\left( x \right) =sgn \left( x \right) \cdot \lfloor \left| x \right| \rfloor $$. 该算子的物理意义为：抹除实数x的小数部分，仅保留整数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义取整准则: 考虑实数 $$X\in \mathbb{R} $$, 其整数部分为 $$I $$, 小数部分为 $$f\in \left[ 0,1 \right) $$. 即满足 $$\left| X \right|=I+f $$. 定义&quot;n舍n+1入&quot;的进位阈值为 $$T\in \left[ 0,1 \right) $$. 则我们期望的取整函数 $$R\left( X,T \right) $$应满足下列条件:&lt;/p&gt;
&lt;p&gt;$$R\left( X,T \right) = \left{ \begin{array}{c} I \cdot \text{sgn} \left( X \right) , f&amp;lt;T\ \left( I+1 \right) \cdot \text{sgn} \left( X \right) , f\ge T\ \end{array} \right. $$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义偏移量: 考虑偏移量 $$\Delta $$, 使得 $$Tr\left( X + \Delta \right) =R\left ( X,T \right)$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;解答&lt;/h2&gt;
&lt;p&gt;为找到偏移量 $$\Delta $$, 进行下列操作:&lt;/p&gt;
&lt;h3&gt;(1) 考虑正数域&lt;/h3&gt;
&lt;p&gt;由于在正数域下，可得: $$\lfloor I + f + \Delta \rfloor = \left{ \begin{array}{c} I, f &amp;lt; T \ I + 1, f \ge T \end{array} \right. $$&lt;/p&gt;
&lt;p&gt;又由底函数性质 $$\lfloor I + \alpha \rfloor = I + \lfloor \alpha \rfloor$$, 可得: $$\lfloor f + \Delta \rfloor = \left{ \begin{array}{c} 0, f + \Delta &amp;lt; 1 \ 1, f + \Delta \ge 1 \end{array} \right. $$&lt;/p&gt;
&lt;p&gt;欲使阈值点 $$f = T$$ 恰好成为进位临界点，则应有: $$ \begin{cases} T + \Delta \ge 1 \implies \Delta \ge 1 - T \ \lim_{\epsilon \to 0} (T - \epsilon) + \Delta &amp;lt; 1 \implies \Delta \leq 1 - T \end{cases} $$&lt;/p&gt;
&lt;p&gt;即得 $$1-T\le \Delta \leq 1-T $$, 则有唯一解为: $$\Delta = 1 - T $$&lt;/p&gt;
&lt;h3&gt;(2) 考虑负数域&lt;/h3&gt;
&lt;p&gt;考虑负数 $$-N=-I-f&amp;lt;0 $$, 其中 $$N, I, f&amp;gt;0 $$.&lt;/p&gt;
&lt;p&gt;由于在复数域下，可得: $$\lfloor -I-f+\Delta \rfloor =\left{ \begin{array}{c} -I,f&amp;lt;T\ -I-1,f\ge T\ \end{array} \right. $$&lt;/p&gt;
&lt;p&gt;即有 $$\lfloor I+f-\Delta \rfloor =\left{ \begin{array}{c} I,f&amp;lt;T\ I+1,f\ge T\ \end{array} \right. $$&lt;/p&gt;
&lt;p&gt;令 $$ \Delta_0 = - \Delta $$, 则有 $$\lfloor I+f+\Delta_0 \rfloor =\left{ \begin{array}{c} I,f&amp;lt;T\ I+1,f\ge T\ \end{array} \right. $$&lt;/p&gt;
&lt;p&gt;则由情况(1)，可得 $$\Delta_0 = 1 - T $$, 进而有: $$\Delta =-\left( 1-T \right) $$&lt;/p&gt;
&lt;h1&gt;结论&lt;/h1&gt;
&lt;p&gt;我们可以得到在n舍n+1入的情况下，偏移量为&lt;code&gt;Δ=1-0.1(n+1)=0.9-0.1n&lt;/code&gt;. 由此我们可以快速设计n舍n+1入算法: &lt;code&gt;static_cast&amp;lt;int&amp;gt;(a+(a==0?0:(0.9-0.1*n)*(a&amp;gt;0?1:(-1))))&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;考虑到&lt;code&gt;-0.0&lt;/code&gt;的存在，我们需要将a==0时的情况改为&lt;code&gt;0.0f&lt;/code&gt;: &lt;code&gt;static_cast&amp;lt;int&amp;gt;(a+(a==0?0.0f:(0.9-0.1*n)*(a&amp;gt;0?1:(-1))))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由于计算机存在精度损失，我们需要考虑以下情况: $$2.5+\left( 0.9-0.1\times 4 \right) \xsim{\text{精度损失}}2.5+0.49999999999=2.99999999999\xrightarrow{static_cast}2$$&lt;/p&gt;
&lt;p&gt;为修正精度丢失所带来的影响，我们可以引入&lt;code&gt;1e-9&lt;/code&gt;项，这使得丢失的精度仍然可以跨过&lt;code&gt;static_cast&amp;lt;int&amp;gt;&lt;/code&gt;的阈值。&lt;/p&gt;
&lt;p&gt;进而可以变为如下形式: &lt;code&gt;static_cast&amp;lt;int&amp;gt;( a + ( a == 0 ? 0.0f : ( 0.9 - 0.1 * n + 1e-9 ) * ( a &amp;gt; 0 ? 1 : -1)))&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;特别地，针对四舍五入的情况，可以得到&lt;code&gt;static_cast&amp;lt;int&amp;gt;( a + ( a == 0 ? 0.0f : ( 0.5 + 1e-9 ) * ( a &amp;gt; 0 ? 1 : -1)))&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;更进一步地，如果能确定数据均为正数或负数，可直接略去三目运算符。&lt;/p&gt;
&lt;h1&gt;优势和劣势&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;该方法在通常情况下会比&lt;code&gt;round()&lt;/code&gt;函数更快，但由于该语句中三目运算符产生的分支，如果输入的数据中大量出现正负交替的现象，则会由于CPU分支预测器的失效导致严重的性能抖动。&lt;/li&gt;
&lt;li&gt;可能存在溢出风险，这需要开发者进行额外的注意（尽管&lt;code&gt;round()&lt;/code&gt;函数也会出现溢出就是了）。&lt;/li&gt;
&lt;/ol&gt;
</content:encoded></item><item><title>L1-011~L1-015的笔记</title><link>https://samera2022.github.io/posts/notes/gplt/l1-011l1-015/</link><guid isPermaLink="true">https://samera2022.github.io/posts/notes/gplt/l1-011l1-015/</guid><description>GPLT的笔记</description><pubDate>Thu, 22 Jan 2026 05:11:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/GPLTNotes&quot;}&lt;/p&gt;
&lt;p&gt;P.S. 这份笔记同步发布在我的博客上，建议在博客中查看以享受完整的MD Extended Features. 你可以点此&lt;a href=&quot;https://samera2022.github.io/posts/Notes/GPLT/l1-011l1-015/&quot;&gt;快速跳转&lt;/a&gt;到相应页面，我的博客地址为https://samera2022.github.io&lt;/p&gt;
&lt;h1&gt;L1-011&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

void solve(string&amp;amp; A, string&amp;amp; B);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    string A;
    getline(cin,A);
    string B;
    getline(cin,B);
    solve(A,B);
    return 0;
}

void solve(string&amp;amp; A, string&amp;amp; B) {
    const int len = static_cast&amp;lt;int&amp;gt;(B.length());
    for (int i = 0; i &amp;lt;= len; i++)
        A.erase(remove(A.begin(),A.end(),B[i-1]), A.end());
    cout&amp;lt;&amp;lt;A;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在Java中，我们可以直接通过&lt;code&gt;replace(CharSequence target, &quot;&quot;)&lt;/code&gt;来快速地删除字符串中全体的某种字符，然而在C++中实现这种操作略微复杂一些。在此我们需要先介绍两个方法：&lt;code&gt;string.erase()&lt;/code&gt;和&lt;code&gt;remove()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;关于&lt;code&gt;string.erase(iterator first, iterator last)&lt;/code&gt;：该方法会移除从&lt;code&gt;first&lt;/code&gt;到&lt;code&gt;last&lt;/code&gt;的所有字符。&lt;/li&gt;
&lt;li&gt;关于&lt;code&gt;remove(iterator first, iterator last, char target)&lt;/code&gt;：该方法会将从&lt;code&gt;first&lt;/code&gt;到&lt;code&gt;last&lt;/code&gt;的所有非&lt;code&gt;target_char&lt;/code&gt;字符向前移动并返回正确新结尾的迭代器，从整体上来看就是把所有的&lt;code&gt;target_char&lt;/code&gt;后移了。&lt;/li&gt;
&lt;li&gt;尽管C++中没有原生的直接移除字符串中某字符的方法，不过有替换字符串中全体某字符为另外一个字符的方法：对于&lt;code&gt;string s&lt;/code&gt;而言，可用&lt;code&gt;replace(s.begin(), s.end(), (char) old_char, (char) new_char)&lt;/code&gt;。由于&lt;code&gt;new_char&lt;/code&gt;必须是一个&lt;code&gt;char&lt;/code&gt;类型，导致不能写&lt;code&gt;&apos;&apos;&lt;/code&gt;进去……&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-012&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n;
    cin&amp;gt;&amp;gt;n;
    cout&amp;lt;&amp;lt;&quot;2^&quot;&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&quot; = &quot;&amp;lt;&amp;lt;pow(2,n);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt;包含在&lt;code&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/code&gt;中，因此在&lt;code&gt;using namespace std&lt;/code&gt;时可以直接使用&lt;code&gt;pow(2, n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-013&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

void solve(int N);
int factorial(int n);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin&amp;gt;&amp;gt;N;
    solve(N);
    return 0;
}

void solve(const int N) {
    int res = 0;
    for (int i = 1; i &amp;lt;= N; i++) res += factorial(i);
    cout&amp;lt;&amp;lt;res;
}

int factorial(const int n) {
    if (n==0) return 1;
    int res = 1;
    for (int i = 1; i &amp;lt;= n; i++) res *= i;
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有什么好记的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-014&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cout&amp;lt;&amp;lt;&quot;This is a simple problem.&quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有什么好记的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-015&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

void solve(int N, const string&amp;amp; delimiter);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin&amp;gt;&amp;gt;N;
    string delimiter;
    cin&amp;gt;&amp;gt;delimiter;
    solve(N,delimiter);
    return 0;
}

void solve(const int N, const string&amp;amp; delimiter) {
    const int row = static_cast&amp;lt;int&amp;gt;(round(static_cast&amp;lt;double&amp;gt;(N)/2));
    for (int i = 1; i &amp;lt;= row; i++) {
        for (int j = 1; j &amp;lt;= N; j++) cout&amp;lt;&amp;lt;delimiter;
        cout&amp;lt;&amp;lt;&quot;\n&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++中四舍五入使用的是&lt;code&gt;round(double)&lt;/code&gt;方法。特别地，该方法返回的仍然为&lt;code&gt;double&lt;/code&gt;类型，需要进一步手动转换。&lt;/li&gt;
&lt;li&gt;由于C++的浮点转整数为&lt;code&gt;去尾&lt;/code&gt;转换，你也可以借助这个性质来快速转换：考虑&lt;code&gt;double a;&lt;/code&gt;，对于正数你可以使用&lt;code&gt;static_cast&amp;lt;int&amp;gt;(a+0.5)&lt;/code&gt;，对于负数你可以使用&lt;code&gt;static_cast&amp;lt;int&amp;gt;(a+(-0.5))&lt;/code&gt;，对于0而言，为了保持统一性，我们需要使用&lt;code&gt;static_cast&amp;lt;int&amp;gt;(a+0.0f)&lt;/code&gt;。因此综合地，你可以使用&lt;code&gt;static_cast&amp;lt;int&amp;gt;( a + ( a == 0 ? 0.0f : ( 0.5 + 1e-9 ) * ( a &amp;gt; 0 ? 1 : -1)))&lt;/code&gt;来进行快速四舍五入。类似地，你可以处理五舍六入等情况。关于偏移截断的内容，详见&lt;a href=&quot;https://samera2022.github.io/posts/Experiences/%E5%9F%BA%E4%BA%8E%E5%81%8F%E7%A7%BB%E6%88%AA%E6%96%AD%E6%B3%95%E7%9A%84n%E8%88%8Dn1%E5%85%A5%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/&quot;&gt;这篇文章&lt;/a&gt;或&lt;a href=&quot;https://zhuanlan.zhihu.com/p/1997742572173555685&quot;&gt;这篇文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果你希望返回其他整数类型，可以采用&lt;code&gt;lround(doble)&lt;/code&gt;（返回&lt;code&gt;long&lt;/code&gt;）和&lt;code&gt;llround(double)&lt;/code&gt;（返回&lt;code&gt;long long&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;特别地，C++并不原生支持四舍五入到N位小数，如果你需要这样的操作，需要先乘以eN倍，取整后再除以eN还原回来。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>L1-006~L1-010的笔记</title><link>https://samera2022.github.io/posts/notes/gplt/l1-006l1-010/</link><guid isPermaLink="true">https://samera2022.github.io/posts/notes/gplt/l1-006l1-010/</guid><description>GPLT的笔记</description><pubDate>Thu, 22 Jan 2026 03:04:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/GPLTNotes&quot;}&lt;/p&gt;
&lt;p&gt;P.S. 这份笔记同步发布在我的博客上，建议在博客中查看以享受完整的MD Extended Features. 你可以点此&lt;a href=&quot;https://samera2022.github.io/posts/Notes/GPLT/l1-006l1-010/&quot;&gt;快速跳转&lt;/a&gt;到相应页面，我的博客地址为https://samera2022.github.io&lt;/p&gt;
&lt;h1&gt;L1-006&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;
//Spec A 2/20 Point

void solve(int N);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin&amp;gt;&amp;gt;N;
    solve(N);
    return 0;
}

void solve(const int N) {
    //Spec Tip Start
    int crtMax = 1;//连续因数的个数的最大值
    int crt = N;//连续因数最小值，当其为质数时即为其本身
    //Spec Tip End
    for (int i = 2; i&amp;lt;=sqrt(N); i++) {
        if (int n = N; n%i==0) {
            int delta = 0;
            bool valid = n%(i+delta)==0;
            while (valid) {
                n/=i+delta;
                valid = n%(i+delta+1)==0;
                if (valid) delta++;
                else break;
            }
            //Spec Tip Start
            //delta+1代表此时的连续因数长度，此时有更长连续因数长度时，对crt进行同步
            if (delta+1&amp;gt;crtMax) {
                crtMax = delta+1;
                crt = i;
            }
            if (crt==N) crt = i;//需要最小因子序列，因此需要考虑其可分解为两数相乘时，连续因数最小值改为最小因数
            //Spec Tip End
        }
    }
    cout&amp;lt;&amp;lt;crtMax&amp;lt;&amp;lt;&quot;\n&quot;;
    for (int i = 0; i &amp;lt; crtMax; i++) {
        cout&amp;lt;&amp;lt;crt+i;
        if (i!=crtMax-1) cout&amp;lt;&amp;lt;&quot;*&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有什么好记的，这题主要是算法上稍微绕了一下。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-007&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

void solve(const string&amp;amp; s);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    string s;
    cin&amp;gt;&amp;gt;s;
    solve(s);
    return 0;
}

void solve(const string&amp;amp; s) {
    string result;
    int len = static_cast&amp;lt;int&amp;gt;(s.length());
    for (int i = 0; i&amp;lt;len; i++) {
        switch (s[i]) {
            case &apos;-&apos;:
                result.append(&quot;fu&quot;);
                break;
            case &apos;1&apos;:
                result.append(&quot;yi&quot;);
                break;
            case &apos;2&apos;:
                result.append(&quot;er&quot;);
                break;
            case &apos;3&apos;:
                result.append(&quot;san&quot;);
                break;
            case &apos;4&apos;:
                result.append(&quot;si&quot;);
                break;
            case &apos;5&apos;:
                result.append(&quot;wu&quot;);
                break;
            case &apos;6&apos;:
                result.append(&quot;liu&quot;);
                break;
            case &apos;7&apos;:
                result.append(&quot;qi&quot;);
                break;
            case &apos;8&apos;:
                result.append(&quot;ba&quot;);
                break;
            case &apos;9&apos;:
                result.append(&quot;jiu&quot;);
                break;
            case &apos;0&apos;:
                result.append(&quot;ling&quot;);
                break;
            default:
                break;
        }
        if (i!=len-1) result.append(&quot; &quot;);
    }
    cout&amp;lt;&amp;lt;result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;此处用到了C++风格的强制转型&lt;code&gt;static_cast&amp;lt;int&amp;gt;()&lt;/code&gt;，Java中的写法&lt;code&gt;(int)&lt;/code&gt;也能用，但是那被称为C风格的强制转型。&lt;/li&gt;
&lt;li&gt;C++中的&lt;code&gt;string&lt;/code&gt;可以像Java的&lt;code&gt;StringBuilder&lt;/code&gt;一样使用&lt;code&gt;append&lt;/code&gt;方法。更进一步地，C++的字符串可以直接编辑原处，而Java的字符串由于其不可变导致只能编辑副本，这使得C++的字符串更轻一些。&lt;/li&gt;
&lt;li&gt;也许有人会说为啥我写这么长的&lt;code&gt;switch-case&lt;/code&gt;都不考虑直接单独处理符号再写个数组来处理0~9，究其根本， 我只能说我想试试C++中的&lt;code&gt;switch-case&lt;/code&gt;和Java中是否一致））&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-008&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;
//Spec A 2/10 Point

void solve(int A, int B);
void handle(int num);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int A;
    cin&amp;gt;&amp;gt;A;
    int B;
    cin&amp;gt;&amp;gt;B;
    solve(A,B);
    return 0;
}

void solve(const int A, const int B) {
    const int total = B - A + 1;
    const int time = total / 5;
    for (int i = 1; i &amp;lt;= time; i++) {
        for (int j = 1; j&amp;lt;=5; j++) handle(A+5*(i-1)+(j-1));
        cout&amp;lt;&amp;lt;&quot;\n&quot;;
    }
    //Spec Tip Start
    if (const int rest = total % 5; rest!=0) {
        for (int j = rest - 1; j &amp;gt;= 0; j--) handle(B-j);
        cout&amp;lt;&amp;lt;&quot;\n&quot;;
    }
    //Spec Tip End
    cout&amp;lt;&amp;lt;&quot;Sum = &quot;&amp;lt;&amp;lt;((A+B)*total/2);
}

void handle(const int num) {
    string s = to_string(num);
    const int len = static_cast&amp;lt;int&amp;gt;(s.length());
    const int lLen = 5 - len;
    for (int i = 1; i &amp;lt;= lLen; i++) cout&amp;lt;&amp;lt;&quot; &quot;;
    cout&amp;lt;&amp;lt;s;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;此处的&lt;code&gt;solve&lt;/code&gt;方法直接采用了值传递。我们可以发现，值传递时，方法参数的&lt;code&gt;const&lt;/code&gt;与否不妨碍其声明中无需写&lt;code&gt;const&lt;/code&gt;。声明中的引用传递的&lt;code&gt;const&lt;/code&gt;主要是为了确保方法不会修改原来的值，而值传递的情况下修改后和原来也无所谓，所以声明中不能再写&lt;code&gt;const&lt;/code&gt;修饰。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-009&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;
//Spec A 11/20 Point

pair&amp;lt;ll, ll&amp;gt; split(const string&amp;amp; s, char delimiter);
ll gcd(ll a, ll b);
void simplify(ll&amp;amp; a, ll&amp;amp; b);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin&amp;gt;&amp;gt;N;
    ll curtNum = 0;
    ll curtDen = 1;
    for (ll i = 1; i &amp;lt;= N; i++) {
        string content;
        cin&amp;gt;&amp;gt;content;
        const auto [Num, Den] = split(content,&apos;/&apos;);
        curtNum = curtNum*Den+curtDen*Num;
        curtDen *= Den;
        simplify(curtNum, curtDen);
    }
    const ll res = curtNum/curtDen;
    ll resNum = curtNum%curtDen;
    simplify(resNum,curtDen);
    if (res==0&amp;amp;&amp;amp;resNum!=0) cout&amp;lt;&amp;lt;resNum&amp;lt;&amp;lt;&quot;/&quot;&amp;lt;&amp;lt;curtDen;
    if (res!=0&amp;amp;&amp;amp;resNum==0) cout&amp;lt;&amp;lt;res;
    if (res!=0&amp;amp;&amp;amp;resNum!=0) cout&amp;lt;&amp;lt;res&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;resNum&amp;lt;&amp;lt;&quot;/&quot;&amp;lt;&amp;lt;curtDen;
    if (res==0&amp;amp;&amp;amp;resNum==0) cout&amp;lt;&amp;lt;0;
    return 0;
}

pair&amp;lt;ll,ll&amp;gt; split(const string&amp;amp; s, const char delimiter) {
    pair&amp;lt;ll,ll&amp;gt; tokens;
    if (s.find(string(1,delimiter))!=string::npos) {
        string token;
        stringstream ss(s);
        getline(ss,token, delimiter);
        tokens.first = stoll(token);
        getline(ss, token, delimiter);
        tokens.second = stoll(token);
    } else {
        tokens.first = stoll(s);
        tokens.second = 1;
    }
    return tokens;
}

ll gcd(ll a, ll b) {
    while (b != 0) {
        a %= b;
        swap(a, b);
    }
    return a;
}

void simplify(ll&amp;amp; a, ll&amp;amp; b) {
    const ll multiplier = gcd(a,b);
    a /= multiplier;
    b /= multiplier;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;我原来写的是先乘出完整的分母，再算出完整的分子，最后直接约分得到结果，但是这题有个小分值的测试点会超&lt;code&gt;long long&lt;/code&gt;的范围，导致只能逐步约分了。&lt;/li&gt;
&lt;li&gt;也许有人会说为什么我要连着写四个&lt;code&gt;if&lt;/code&gt;而不用&lt;code&gt;if else-if else&lt;/code&gt;，再或者在每个if的结构体中直接&lt;code&gt;return 0;&lt;/code&gt;。究其根本，我只能说这是对称美）））言归正传，这确实会损失少量性能，不过我还是觉得这很美观））&lt;/li&gt;
&lt;li&gt;本题中可能出现负数，在实际操作中求最大公约数(&lt;code&gt;gcd&lt;/code&gt;)是可以正常处理负数的，但是返回的结果可能需要进一步的操作。因而我直接采用了绝对值计算，这会保险一些。&lt;/li&gt;
&lt;li&gt;另记：有人可能会采用递归写法的&lt;code&gt;gcd&lt;/code&gt;，需要补充的是，在递归深度达到1e5或1e6时，递归可能导致栈溢出(&lt;code&gt;Stack Overflow&lt;/code&gt;)，而循环则不会出现这种问题。此外，递归涉及调用、压栈、弹栈、参数传递等CPU操作，这也使得其常数时间通常比循环要大。&lt;/li&gt;
&lt;li&gt;C++中没有现成的&lt;code&gt;split&lt;/code&gt;方法，需要你手动进行实现……因此，我们需要清楚&lt;code&gt;getline()&lt;/code&gt;的具体作用：首先需要指出的是，这是&lt;code&gt;getline()&lt;/code&gt;函数的其中一个作用，另外一个作用等到下一次见到它的时候再说。该函数有三个参数，此处我们填入的是&lt;code&gt;(stringstream, string, char)&lt;/code&gt;。&lt;code&gt;getline&lt;/code&gt;首先会清空&lt;code&gt;string&lt;/code&gt;中原有的内容，而后从&lt;code&gt;stringstream&lt;/code&gt;中逐个读取字符，一直读取到&lt;code&gt;char&lt;/code&gt;出现时停止读取，此时会将读取到的&lt;code&gt;char&lt;/code&gt;之前的字符串存入你提供的&lt;code&gt;string&lt;/code&gt;中。如果不填入&lt;code&gt;char&lt;/code&gt;，则其会默认读到行末换行（不包含换行符）。由于内容会被存入&lt;code&gt;string&lt;/code&gt;，这使得你只能传入左值(&lt;code&gt;L-Value&lt;/code&gt;)进去。在这种情况下，&lt;code&gt;getline&lt;/code&gt;起到的实际上是字符分割的作用。&lt;/li&gt;
&lt;li&gt;另记：左值(&lt;code&gt;L-Value&lt;/code&gt;)是一个正常的变量，你可以通过变量名来访问它。右值(&lt;code&gt;R-Value&lt;/code&gt;)是一个临时变量，你无法通过变量名来访问它（因为它不存在变量名）。比方说，&lt;code&gt;to_string(num)&lt;/code&gt;是一个匿名返回值，你无法用一个变量名来访问它；&lt;code&gt;&quot;42&quot;&lt;/code&gt;是一个字面量，你也无法用一个变量名来访问它。这些变量在所在行结束后就会被销毁，因而被算作右值(&lt;code&gt;R-Value&lt;/code&gt;)。简单地说，你可以通过“是否有一个变量名”来快速判断左右值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-010&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int A,B,C = 0;
    cin&amp;gt;&amp;gt;A;
    cin&amp;gt;&amp;gt;B;
    cin&amp;gt;&amp;gt;C;
    vector v = {A,B,C};
    sort(v.begin(), v.end());
    for (int i = 1; i &amp;lt;= 3; i++) {
        cout&amp;lt;&amp;lt;v[i-1];
        if (i!=3) cout&amp;lt;&amp;lt;&quot;-&amp;gt;&quot;;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一个比大小的题目，可以用&lt;code&gt;if-else&lt;/code&gt;来判断得到排序结果。这里我懒了一下，直接用数组排序了。&lt;/li&gt;
&lt;li&gt;C++的&lt;code&gt;vector&lt;/code&gt;和Java的&lt;code&gt;ArrayList&lt;/code&gt;性质相似，但是在查询元素位置的时候，如果你使用&lt;code&gt;vector.at(i)&lt;/code&gt;，其会因为越界检查而比&lt;code&gt;vector[i]&lt;/code&gt;要更慢。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>L1-001~L1-005的笔记</title><link>https://samera2022.github.io/posts/notes/gplt/l1-001l1-005/</link><guid isPermaLink="true">https://samera2022.github.io/posts/notes/gplt/l1-001l1-005/</guid><description>GPLT的笔记</description><pubDate>Wed, 21 Jan 2026 15:40:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/GPLTNotes&quot;}&lt;/p&gt;
&lt;p&gt;P.S. 这份笔记同步发布在我的博客上，建议在博客中查看以享受完整的MD Extended Features. 你可以点此&lt;a href=&quot;https://samera2022.github.io/posts/Notes/GPLT/l1-001l1-005/&quot;&gt;快速跳转&lt;/a&gt;到相应页面，我的博客地址为https://samera2022.github.io&lt;/p&gt;
&lt;h1&gt;L1-001&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cout &amp;lt;&amp;lt; &quot;Hello World!&quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#include&lt;/code&gt;属于&lt;code&gt;预处理语句&lt;/code&gt;，在编译期会对这些语句进行复制操作。即，将目标文件的内容原封不动地剪切到本文件的这一行。第一句为导入&lt;code&gt;bits/stdc++.h&lt;/code&gt;这个头文件，该头文件包含大量常用的&lt;code&gt;#include&lt;/code&gt;语句，因此又被称为“万用头”。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;using namespace&lt;/code&gt;是&lt;code&gt;使用命名空间&lt;/code&gt;，在C++中这是为了解决命名冲突而诞生的，在Java中该操作类似于&lt;code&gt;static import&lt;/code&gt;的效果。未使用&lt;code&gt;std&lt;/code&gt;命名空间时，所有试图调用&lt;code&gt;std&lt;/code&gt;的操作都需要通过&lt;code&gt;std::xxx&lt;/code&gt;来实现，而使用后则可直接操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typedef&lt;/code&gt;是起别名，在此例中是将&lt;code&gt;long long&lt;/code&gt;全部改名为ll，这使得你的输入更加方便。&lt;/li&gt;
&lt;li&gt;另记：C++中int的范围和Java中int的范围一致；&lt;code&gt;long long&lt;/code&gt;的范围和Java中&lt;code&gt;long&lt;/code&gt;的范围一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ios::sync_with_stdio(false);&lt;/code&gt;是关闭C++输入输出流（如&lt;code&gt;cin&lt;/code&gt;和&lt;code&gt;cout&lt;/code&gt;）和C标准库的输入输出函数（如&lt;code&gt;scanf&lt;/code&gt;和&lt;code&gt;printf&lt;/code&gt;）的同步状态，这会加快输入输出速度，代价是不能再混合使用&lt;code&gt;cin&lt;/code&gt;和&lt;code&gt;scanf&lt;/code&gt; 以及 &lt;code&gt;cout&lt;/code&gt;和&lt;code&gt;printf&lt;/code&gt;，因为他们执行的顺序是不同步的。在这种情况下，建议只使用cin和cout。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cin.tie(nullptr)&lt;/code&gt;会取消&lt;code&gt;cin&lt;/code&gt;与&lt;code&gt;cout&lt;/code&gt;的绑定，进而使用&lt;code&gt;cin&lt;/code&gt;时不再会强制刷新&lt;code&gt;cout&lt;/code&gt;的缓冲区，进而加快输入输出速度。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout.tie(nullptr)&lt;/code&gt;其实没有什么用，写上这一句大多数出于心理安慰，或者避免极少数情况下&lt;code&gt;cout&lt;/code&gt;被意外绑定到其他输出流。&lt;/li&gt;
&lt;li&gt;另记：有人认为&lt;code&gt;nullptr&lt;/code&gt;空指针是AI才会写的形式，进而推荐直接写0进去。我对此持保留意见，后面的代码仍然会沿用&lt;code&gt;nullptr&lt;/code&gt;的写法。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    cout &amp;lt;&amp;lt; &quot;Hello World!&quot;;
    return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;用于&lt;code&gt;cout&lt;/code&gt;的&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;是一个新的符号，可以认为将右侧的内容推送到左端去，同理用于&lt;code&gt;cin&lt;/code&gt;的&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;是将左侧的内容推送到右端去。二者属于&lt;code&gt;流插入运算符&lt;/code&gt;，是通过重载位左/右移运算符实现的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return 0&lt;/code&gt;中的0是退出状态码，也就是你在IDE下方控制台在最后经常看到的“&lt;code&gt;进程已结束，退出代码为 0&lt;/code&gt;”的那个0。在&lt;code&gt;main&lt;/code&gt;函数中其实可以省略，因为省略之后编译器会默认采用&lt;code&gt;return 0&lt;/code&gt;。对于在线评测系统而言，通常要求返回值必须为0，这导致你在&lt;code&gt;main&lt;/code&gt;中写不写返回其实没有影响。&lt;/li&gt;
&lt;li&gt;另记：“补全&lt;code&gt;return 0&lt;/code&gt;”的操作编译器只会在&lt;code&gt;main&lt;/code&gt;函数，即你的入口函数(&lt;code&gt;int main&lt;/code&gt;)进行。对于其他的非&lt;code&gt;void&lt;/code&gt;的函数，你仍然需要手动写出所有的返回语句。
:::info
这份代码基本是以后所有代码的模板。即，之后的代码基本都会以这样的形式给出。
:::&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-002&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

void solve(int N, char style);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin &amp;gt;&amp;gt; N;
    char style;
    cin&amp;gt;&amp;gt;style;
    solve(N, style);
    return 0;
}

void solve(const int N, const char style) {
    const int time = static_cast&amp;lt;int&amp;gt;(pow(((N + 1) / 2), 0.5));
    const int rest = N - (2 * time * time - 1);
    const int max = 2 * time - 1;
    for (int i = 1; i &amp;lt;= time; i++) {
        for (int k = 0; k &amp;lt; i - 1; k++) cout &amp;lt;&amp;lt; &quot; &quot;;
        for (int j = 1; j &amp;lt;= max - 2 * (i - 1); j++) cout &amp;lt;&amp;lt; style;
        cout &amp;lt;&amp;lt; &quot;\n&quot;;
    }
    for (int i = 2; i &amp;lt;= time; i++) {
        for (int k = 0; k &amp;lt; time - i; k++) cout &amp;lt;&amp;lt; &quot; &quot;;
        for (int j = 1; j &amp;lt;= 2 * i - 1; j++) cout &amp;lt;&amp;lt; style;
        cout &amp;lt;&amp;lt; &quot;\n&quot;;
    }
    cout &amp;lt;&amp;lt; rest;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++相较于Java有一点比较独特，如果调用的方法写在下方的话，则需要在在上方先写一个声明以供链接。因此也有不少人选择将&lt;code&gt;solve&lt;/code&gt;方法写在&lt;code&gt;main&lt;/code&gt;函数的上面。&lt;/li&gt;
&lt;li&gt;C++对于只有单语句的循环也可以省略大括号，这一点在Java中是没有的。&lt;/li&gt;
&lt;li&gt;我对于所有的常量都加&lt;code&gt;const&lt;/code&gt;修饰了，这可能会对C++比较熟练的人造成疑惑。这其实只是我为了不想看见编译器中的黄色弱警告干的）））我知道这种写法比较抽象，可能类似于IDEA中把每一个提示警告的全局的变量都上了一个&lt;code&gt;final&lt;/code&gt;修饰一样生草，我也知道可以通过修改编译器显示警告的方案来取消显示这些警告，但是我还是觉得这么写会好一些）））&lt;/li&gt;
&lt;li&gt;有的人换行可能会采用&lt;code&gt;endl&lt;/code&gt;，不过我还是沿用Java的&lt;code&gt;&quot;\n&quot;&lt;/code&gt;。前者会刷新输出缓冲区而后者不会，因此后者的效率也会更高一些。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-003&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

void solve(const string&amp;amp; s);

int cnt[10];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    string s;
    cin &amp;gt;&amp;gt; s;
    solve(s);
    return 0;
}

void solve(const string&amp;amp; s) {
    int len = static_cast&amp;lt;int&amp;gt;(s.length());
    for (int i = 0; i &amp;lt; len; i++) {
        cnt[s.at(i)-&apos;0&apos;]++;
    }
    for (int i = 0; i &amp;lt; 10; i++) {
        if (cnt[i]!=0) cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot;:&quot;&amp;lt;&amp;lt;cnt[i]&amp;lt;&amp;lt;&quot;\n&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int cnt[10]&lt;/code&gt;是C++数组的写法。在开启编译器优化时，读取和写入操作&lt;code&gt;vector&lt;/code&gt;(C++的列表)能做到和它一样快。&lt;/li&gt;
&lt;li&gt;另记：C++中的数组在局部可变长度，即，你可以在局部声明一个&lt;code&gt;int N&lt;/code&gt;填入&lt;code&gt;int cnt[]&lt;/code&gt;中，ze&lt;code&gt;cnt&lt;/code&gt;长度会随&lt;code&gt;N&lt;/code&gt;的变化而改变。特别地，在全局你只能声明确定长度的数组。&lt;/li&gt;
&lt;li&gt;这里用到了引用&lt;code&gt;&amp;amp;&lt;/code&gt;，Java中的参数传递只有&lt;code&gt;值传递&lt;/code&gt;，而C++中可以做到&lt;code&gt;引用传递&lt;/code&gt;。在方法的参数列表中，在变量名旁边加&lt;code&gt;&amp;amp;&lt;/code&gt;即认为是传递引用。特别地，如果传递的是引用，则需要在最上方声明时同样改为引用传递。&lt;/li&gt;
&lt;li&gt;指针的大小为8字节，因此在&lt;code&gt;可以选择&lt;/code&gt;值/引用传递时，对于基础类型（除&lt;code&gt;long double&lt;/code&gt;之外），传入参数时需要使用值传递；对于引用类型，传入参数时需要使用引用传递。如果你的方法本身就需要修改原来变量的值，请继续使用引用传递。如果你的方法本身就希望修改值，但不希望修改原来变量，请继续使用值传递。&lt;/li&gt;
&lt;li&gt;另记：常用的基础类型：&lt;code&gt;bool&lt;/code&gt; &lt;code&gt;char&lt;/code&gt; &lt;code&gt;short&lt;/code&gt; &lt;code&gt;int&lt;/code&gt; &lt;code&gt;long&lt;/code&gt;（←不建议使用） &lt;code&gt;long long&lt;/code&gt; &lt;code&gt;float&lt;/code&gt;（←不建议使用） &lt;code&gt;double&lt;/code&gt; &lt;code&gt;long double&lt;/code&gt;。除了&lt;code&gt;long double&lt;/code&gt;，其他所有的基础类型大小都小于等于8字节。&lt;/li&gt;
&lt;li&gt;另记：特别地，&lt;code&gt;long&lt;/code&gt;在Windows中为4字节，在Linux中为8字节，因此请不要使用&lt;code&gt;long&lt;/code&gt;，改用&lt;code&gt;long long&lt;/code&gt;（全平台均为8字节）更加稳妥。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s.at(i)-&apos;0&apos;&lt;/code&gt;是C++中&lt;code&gt;char&lt;/code&gt;转&lt;code&gt;int&lt;/code&gt;的方式。不要采用&lt;code&gt;stoi(to_string(s.at(i)))&lt;/code&gt;！因为C++中的&lt;code&gt;char&lt;/code&gt;类型本身即可作为&lt;code&gt;int&lt;/code&gt;，这会输出它们的ASCII码。这使得后者输出的即为ASCII，而前者通过减去基准的&apos;0&apos;获得的相对偏移量才是数字本身。&lt;/li&gt;
&lt;li&gt;另记：特别地，Java中的char为2字节（UTF-16），而C++中的char为1字节（Unicode），其本质为8位整数，因而C++中的&lt;code&gt;char&lt;/code&gt;类型才可以本身即可作为&lt;code&gt;int&lt;/code&gt;输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-004&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

void solve(int F);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int F;
    cin&amp;gt;&amp;gt;F;
    solve(F);
    return 0;
}

void solve(const int F) {
    cout&amp;lt;&amp;lt;&quot;Celsius = &quot;&amp;lt;&amp;lt;5*(F-32)/9;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有什么好记的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;L1-005&lt;/h1&gt;
&lt;h2&gt;代码部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int total;
    cin&amp;gt;&amp;gt;total;
    string arr[total+1];//开大一位，方便后面查询
    for (int i = 0; i &amp;lt; total; i++) {
        string s;
        cin&amp;gt;&amp;gt;s;
        int seat1;
        cin&amp;gt;&amp;gt;seat1;
        int seat2;
        cin&amp;gt;&amp;gt;seat2;
        arr[seat1] = s + &quot; &quot; + to_string(seat2);
    }
    int ask_total;
    cin&amp;gt;&amp;gt;ask_total;
    for (int i = 0; i &amp;lt; ask_total; i++) {
        int j;
        cin&amp;gt;&amp;gt;j;
        cout&amp;lt;&amp;lt;arr[j]&amp;lt;&amp;lt;&quot;\n&quot;;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;笔记部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有什么好记录的，此处&lt;code&gt;string[]&lt;/code&gt;开大一位是因为后面出现了越界，而在这里多开一位是修改量最小的方法。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>AdvancedClipboard-0.2.0 Release</title><link>https://samera2022.github.io/posts/projects/advancedclipboard/advancedclipboard-020-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/advancedclipboard/advancedclipboard-020-release/</guid><description>AdvancedClipboard Updates</description><pubDate>Fri, 16 Jan 2026 16:05:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/AdvancedClipboard&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-17 00:05] 0.2.0 &lt;a href=&quot;https://www.github.com/Samera2022/AdvancedClipboard/releases/tag/0.2.0&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;添加鼠标左键托盘图标呼出UI界面的功能。&lt;/li&gt;
&lt;li&gt;实现回车确认UI选中项的功能。&lt;/li&gt;
&lt;li&gt;托盘右键菜单添加“更新日志”条目。&lt;/li&gt;
&lt;li&gt;托盘右键菜单添加“关于作者”条目。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>DictionaryViewer-0.2.0 Release</title><link>https://samera2022.github.io/posts/projects/dictionaryviewer/dictionaryviewer-020-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/dictionaryviewer/dictionaryviewer-020-release/</guid><description>DictionaryViewer Updates</description><pubDate>Fri, 16 Jan 2026 13:48:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/DictionaryViewer&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-16 21:48] 0.2.0 &lt;a href=&quot;https://www.github.com/Samera2022/DictionaryViewer/releases/tag/0.2.0&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;重构了 IH 和 UDL 窗体，提取了通用的 BaseDictionaryFrame 父类，统一了 UI 风格和逻辑。&lt;/li&gt;
&lt;li&gt;实现了表格列的排序功能，支持点击表头进行降序/升序切换。&lt;/li&gt;
&lt;li&gt;优化了文件打开逻辑，增加了对 .dat 文件类型的检查。&lt;/li&gt;
&lt;li&gt;调整了窗体默认尺寸，优化了布局。&lt;/li&gt;
&lt;li&gt;新增了“导出”功能，支持将词库导出为 CSV、TXT 和 JSON 格式。&lt;/li&gt;
&lt;li&gt;新增了“另存为”功能，支持将当前词库文件另存到其他位置。&lt;/li&gt;
&lt;li&gt;新增了“关闭”功能，支持关闭当前打开的词库。&lt;/li&gt;
&lt;li&gt;新增了多语言支持（国际化），支持动态切换语言（zh_cn, en_us, ru_ru, jp_ja, fr_fr, es_es），并实现了界面文本的即时刷新。&lt;/li&gt;
&lt;li&gt;新增了“其他”菜单，包含“关于作者”和“更新日志”对话框。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Changed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;删除了最开始的词典修改支持。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>IDEA完整修改项目名称的方法</title><link>https://samera2022.github.io/posts/experiences/idea%E5%AE%8C%E6%95%B4%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E7%9A%84%E6%96%B9%E6%B3%95/</link><guid isPermaLink="true">https://samera2022.github.io/posts/experiences/idea%E5%AE%8C%E6%95%B4%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>在IntelliJ IDEA中完整修改项目名称的方法</description><pubDate>Fri, 16 Jan 2026 08:18:00 GMT</pubDate><content:encoded>&lt;h1&gt;修改流程&lt;/h1&gt;
&lt;p&gt;首先你需要在&lt;code&gt;文件-&amp;gt;项目结构-&amp;gt;项目&lt;/code&gt;条目下，修改右侧的&lt;code&gt;名称&lt;/code&gt;和&lt;code&gt;编译器输出&lt;/code&gt;为新的名字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;res/20260116-01.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;p&gt;若需要修改模块名称，则需要在&lt;code&gt;文件-&amp;gt;项目结构&lt;/code&gt;的&lt;code&gt;项目设置-&amp;gt;模块&lt;/code&gt;条目下，修改相应的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;res/20260116-02.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;p&gt;之后你需要修改项目文件夹根目录的名字，可在主界面左侧的&lt;code&gt;项目&lt;/code&gt;界面，右键最上方的模块，选择&lt;code&gt;打开于-&amp;gt;资源管理器&lt;/code&gt;来快捷跳转。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;res/20260116-03.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;p&gt;修改成功后可 重启IDEA 或 &lt;code&gt;文件-&amp;gt;关闭项目&lt;/code&gt;，右键原来的项目，选择&lt;code&gt;从最近的项目中移除...&lt;/code&gt;或直接点击右侧的×号。&lt;/p&gt;
&lt;p&gt;:::warning
现在仍然不能直接在IDEA中打开修改后的项目文件夹，因为项目目前无法建立正确的索引。直观地来看，表现为左侧只出现.iml和.gitignore，同时无法识别其他的文件（夹）。
:::&lt;/p&gt;
&lt;p&gt;然后在资源管理器中打开&lt;code&gt;项目名称/.idea&lt;/code&gt;，修改&lt;code&gt;modules.xml&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project version=&quot;4&quot;&amp;gt;
  &amp;lt;component name=&quot;ProjectModuleManager&quot;&amp;gt;
    &amp;lt;modules&amp;gt;
      &amp;lt;module fileurl=&quot;file://$PROJECT_DIR$/YourProjectOldName.iml&quot; filepath=&quot;$PROJECT_DIR$/YourProjectOldName.iml&quot; /&amp;gt;
      &amp;lt;module fileurl=&quot;file://$PROJECT_DIR$/YourProjectNewName.iml&quot; filepath=&quot;$PROJECT_DIR$/YourProjectNewName.iml&quot; /&amp;gt;
    &amp;lt;/modules&amp;gt;
  &amp;lt;/component&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后需要修改相应的构建配置。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于maven构建的项目，需要修改&lt;code&gt;pom.xml&lt;/code&gt;中的&lt;code&gt;&amp;lt;artifactId&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;（后者决定了IDEA的Maven面板和生成文档时显示的名字）。&lt;/li&gt;
&lt;li&gt;对于gradle构建的项目，需要修改&lt;code&gt;settings.gradle或settings.gradle.kts&lt;/code&gt;中的&lt;code&gt;rootProject.name&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;对于其他方式构建的项目，需要修改相应的配置文件参数和&lt;code&gt;文件-&amp;gt;项目结构-&amp;gt;工件&lt;/code&gt;的相关信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此，项目的重命名就基本完成了。项目此刻应该可以正常被运行和构建。&lt;/p&gt;
&lt;p&gt;如果你 未经IDEA的重命名功能，手动重命名了包名，则需继续参考以下文章来进行修改。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://samera2022.github.io/posts/Experiences/idea%E6%89%8B%E5%8A%A8%E4%BF%AE%E6%94%B9%E5%8C%85%E5%90%8D%E7%9A%84%E7%9B%B8%E5%BA%94%E6%8E%AA%E6%96%BD/&quot;&gt;IDEA手动修改包名的相应措施&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;常见错误&lt;/h1&gt;
&lt;p&gt;当你看到IDEA提示&lt;code&gt;Git Repositories Found: The directory [旧路径] is registered as a Git root, but no Git repository was found there.&lt;/code&gt;时，这表明你需要更新IDEA中的Git映射。&lt;/p&gt;
&lt;p&gt;具体地，你需要在&lt;code&gt;文件-&amp;gt;设置-&amp;gt;版本控制-&amp;gt;目录映射&lt;/code&gt;中点击-删除旧路径，并点击+添加新路径。建议启用下方的&lt;code&gt;启用自动映射检测&lt;/code&gt;，这会节省一些功夫。&lt;/p&gt;
</content:encoded></item><item><title>IDEA手动修改包名的相应措施</title><link>https://samera2022.github.io/posts/experiences/idea%E6%89%8B%E5%8A%A8%E4%BF%AE%E6%94%B9%E5%8C%85%E5%90%8D%E7%9A%84%E7%9B%B8%E5%BA%94%E6%8E%AA%E6%96%BD/</link><guid isPermaLink="true">https://samera2022.github.io/posts/experiences/idea%E6%89%8B%E5%8A%A8%E4%BF%AE%E6%94%B9%E5%8C%85%E5%90%8D%E7%9A%84%E7%9B%B8%E5%BA%94%E6%8E%AA%E6%96%BD/</guid><description>IDEA手动修改包名的相应措施</description><pubDate>Fri, 16 Jan 2026 08:18:00 GMT</pubDate><content:encoded>&lt;p&gt;本文主要讨论 未经IDEA的重命名功能 情况下，手动修改包名所需要修改的构建文件的位置。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于maven构建的项目，需要修改&lt;code&gt;pom.xml&lt;/code&gt;中的&lt;code&gt;&amp;lt;groupId&amp;gt;&lt;/code&gt;和下列代码段（如有）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.2.0&amp;lt;/version&amp;gt;
    &amp;lt;configuration&amp;gt;
        &amp;lt;archive&amp;gt;
            &amp;lt;manifest&amp;gt;
                &amp;lt;mainClass&amp;gt;com.oldname.Main&amp;lt;/mainClass&amp;gt; 
                &amp;lt;mainClass&amp;gt;com.newname.Main&amp;lt;/mainClass&amp;gt; 
                &amp;lt;addDefaultImplementationEntries&amp;gt;true&amp;lt;/addDefaultImplementationEntries&amp;gt;
            &amp;lt;/manifest&amp;gt;
        &amp;lt;/archive&amp;gt;
    &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;对于gradle构建的项目，需要修改&lt;code&gt;build.gradle&lt;/code&gt;中的&lt;code&gt;group&lt;/code&gt;和下列代码段（如有）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;application {
    mainClass = &apos;com.oldname.Main&apos; 
    mainClass = &apos;com.newname.Main&apos; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你手动配置了jar任务，则需修改下列代码段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jar {
    manifest {
        attributes(
            &apos;Main-Class&apos;: &apos;com.oldname.Main&apos; 
            &apos;Main-Class&apos;: &apos;com.newname.Main&apos; 
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;对于其他方式构建的项目，需要修改&lt;code&gt;MANIFEST.MF&lt;/code&gt;中的&lt;code&gt;Main-Class&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
</content:encoded></item><item><title>DictionaryViewer-0.1.0 Release</title><link>https://samera2022.github.io/posts/projects/dictionaryviewer/dictionaryviewer-010-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/dictionaryviewer/dictionaryviewer-010-release/</guid><description>DictionaryViewer Updates</description><pubDate>Thu, 15 Jan 2026 15:53:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/DictionaryViewer&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-15 23:53] 0.1.0 &lt;a href=&quot;https://www.github.com/Samera2022/DictionaryViewer/releases/tag/0.1.0&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;实现了对微软拼音输入法二进制文件的解析逻辑&lt;/li&gt;
&lt;li&gt;创建了基础的 Swing 窗体 (&lt;code&gt;IHMainFrame&lt;/code&gt;, &lt;code&gt;UDLMainFrame&lt;/code&gt;) 以可视化二进制数据。&lt;/li&gt;
&lt;li&gt;实现了对词条的实时关键词过滤功能。&lt;/li&gt;
&lt;li&gt;添加了从 Windows &lt;code&gt;%APPDATA%&lt;/code&gt; 目录自动定位并加载词典文件的逻辑。&lt;/li&gt;
&lt;li&gt;数据显示支持: IH显示“词语”和“词频” ; UDL显示“词条”和“类型”（用户定义/系统学习）。&lt;/li&gt;
&lt;li&gt;添加初步的词典修改支持。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>AdvancedClipboard-0.0.1 Release</title><link>https://samera2022.github.io/posts/projects/advancedclipboard/advancedclipboard-001/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/advancedclipboard/advancedclipboard-001/</guid><description>AdvancedClipboard Updates</description><pubDate>Thu, 15 Jan 2026 07:30:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/AdvancedClipboard&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-15 15:30] 0.0.1 &lt;a href=&quot;https://www.github.com/Samera2022/AdvancedClipboard/releases/tag/0.0.1&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;实现剪贴板历史记录功能 (文本和图片)。&lt;/li&gt;
&lt;li&gt;实现系统托盘图标及退出菜单。&lt;/li&gt;
&lt;li&gt;实现全局热键 (Ctrl+Up/Down) 弹出历史窗口。&lt;/li&gt;
&lt;li&gt;实现从历史窗口选择并恢复到剪贴板的功能。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>UnusualChineseChess-2.0.1 Release</title><link>https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-201-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-201-release/</guid><description>UnusualChineseChess Updates</description><pubDate>Wed, 14 Jan 2026 12:42:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/UnusualChineseChess&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-14 20:42] 2.0.1 &lt;a href=&quot;https://www.github.com/Samera2022/UnusualChineseChess/releases/tag/2.0.1&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Fixed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;修复残局导入的异常。&lt;/li&gt;
&lt;li&gt;修复玩家胜利的判断逻辑。&lt;/li&gt;
&lt;li&gt;修复正常移动到己方底线的“允许己方底线底线晋升”的棋子转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Warn]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;“堆叠棋子”被发现具有很多潜在的问题，但目前尚无法被解决。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>UnusualChineseChess-2.0.0 Release</title><link>https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-200-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-200-release/</guid><description>UnusualChineseChess Updates</description><pubDate>Wed, 14 Jan 2026 06:10:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/UnusualChineseChess&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-14 14:10] 2.0.0 &lt;a href=&quot;https://www.github.com/Samera2022/UnusualChineseChess/releases/tag/2.0.0&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;恢复了先前版本中的“显示提示”勾选框。&lt;/li&gt;
&lt;li&gt;将“强制走子”纳入玩法的可选项。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Changed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大规模重构底层结构，重点重构了“玩法创建”的相关逻辑。新版本的玩法注册逻辑可参照docs/如何创建新玩法(2.X.X)。&lt;/li&gt;
&lt;li&gt;修改了相关玩法的注册名，这使得无法同1.X.X版本的带有玩法的联机进行兼容（1.3.0版本除外）。
注：玩法注册名的修改是从1.3.0开始的，这使得1.3.0无法同前面版本进行带有玩法的联机兼容。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>UnusualChineseChess-1.3.0 Release</title><link>https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-130-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-130-release/</guid><description>UnusualChineseChess Updates</description><pubDate>Mon, 12 Jan 2026 16:51:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/UnusualChineseChess&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-13 00:51] 1.3.0 &lt;a href=&quot;https://www.github.com/Samera2022/UnusualChineseChess/releases/tag/1.3.0&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;添加断网重连支持。当其中一方掉线后，其按照地址重新加入即可继续原先的对局！&lt;/li&gt;
&lt;li&gt;增加主机切换持方的支持。在对局过程中，主机方可以任意修改自己和对方的持方了！&lt;/li&gt;
&lt;li&gt;增加“强制走子”和联机时的“规则改变”到“着法记录”中。现在上述的两个内容将会在客户端和服务端的“着法记录”中显示，并可正常导出到残局中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Fixed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;修复联机与本地环境下鼠标左键对于双方“堆叠棋子”的行为。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>UnusualChineseChess-1.2.0 Release</title><link>https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-120-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-120-release/</guid><description>UnusualChineseChess Updates</description><pubDate>Sat, 10 Jan 2026 11:25:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/UnusualChineseChess&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-10 19:25] 1.2.0 &lt;a href=&quot;https://www.github.com/Samera2022/UnusualChineseChess/releases/tag/1.2.0&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;添加“取消对将”的玩法。&lt;/li&gt;
&lt;li&gt;添加“死战方休”的玩法。&lt;/li&gt;
&lt;li&gt;统一并强化玩法配置管理：全面使用 GameRulesConfig 作为规则单一数据源，减少了模块间耦合。&lt;/li&gt;
&lt;li&gt;运行时差分同步：主机修改玩法设置时仅发送发生改动的字段（diff），并在客户端合并应用。&lt;/li&gt;
&lt;li&gt;在 UI 端对设置变更做 200ms 去抖合并，减少网络抖动。&lt;/li&gt;
&lt;li&gt;增加规则变更监听（支持变更来源），通知执行带超时（500ms）与错误日志，提升稳定性与可调试性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Changed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;移除了大量对 GameEngine 的冗余包装 getter，调用方改为直接访问 GameRulesConfig 的 getBoolean/getInt/toJson 接口。&lt;/li&gt;
&lt;li&gt;RuleSettingsPanel 的绑定逻辑改为直接读写 GameRulesConfig，并在本地 UI 变更时标记变更来源为 UI。&lt;/li&gt;
&lt;li&gt;GameEngine.shutdown() 集成了规则通知器的关闭（集中化资源清理）。&lt;/li&gt;
&lt;li&gt;精简版本与更新信息的调用：将对 UpdateInfo 的全限定调用替换为直接导入后使用，简化了网络握手与 UI 显示逻辑的代码可读性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Fixed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;补充“对将”这一“将”的移动方式。&lt;/li&gt;
&lt;li&gt;修正“帥”和“兵”在左右连通中的表现。&lt;/li&gt;
&lt;li&gt;修复局域网对局中“撤销”按钮，现在其可以在联机中正常使用了。&lt;/li&gt;
&lt;li&gt;修复堆叠棋子的移动验证逻辑，现在选择不同堆栈层的棋子会正确使用对应棋子的移动规则。&lt;/li&gt;
&lt;li&gt;修复“允许背负上方棋子”选项，现在未勾选时选择下方棋子移动不会带走上方棋子。&lt;/li&gt;
&lt;li&gt;修复残局导入导出功能，现在可以正确保存和恢复堆叠棋子的状态。&lt;/li&gt;
&lt;li&gt;修复点击对方堆叠棋子时的交互，现在会显示堆叠信息对话框。&lt;/li&gt;
&lt;li&gt;修复/缓解了规则通知过程中异常被吞掉或阻塞的问题（现在会记录关键错误并对超时 listener 进行取消）。&lt;/li&gt;
&lt;li&gt;修复联机设置同步与撤销相关的问题，主机端现在会发送设置快照/差分并避免回环。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>UnusualChineseChess-1.2.0-26m01c Release</title><link>https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-120-26m01c-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-120-26m01c-release/</guid><description>UnusualChineseChess Updates</description><pubDate>Sat, 10 Jan 2026 07:11:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/UnusualChineseChess&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-10 15:11] 1.2.0-26m01c &lt;a href=&quot;https://www.github.com/Samera2022/UnusualChineseChess/releases/tag/1.2.0-26m01c&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;添加“取消对将”的玩法。&lt;/li&gt;
&lt;li&gt;添加“死战方休”的玩法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Fixed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;补充“对将”这一“将”的移动方式。&lt;/li&gt;
&lt;li&gt;修正“帥”和“兵”在左右连通中的表现。&lt;/li&gt;
&lt;li&gt;修复局域网对局中“撤销”按钮，现在其可以在联机中正常使用了。&lt;/li&gt;
&lt;li&gt;修复堆叠棋子的移动验证逻辑，现在选择不同堆栈层的棋子会正确使用对应棋子的移动规则。&lt;/li&gt;
&lt;li&gt;修复“允许背负上方棋子”选项，现在未勾选时选择下方棋子移动不会带走上方棋子。&lt;/li&gt;
&lt;li&gt;修复残局导入导出功能，现在可以正确保存和恢复堆叠棋子的状态。&lt;/li&gt;
&lt;li&gt;修复点击对方堆叠棋子时的交互，现在会显示堆叠信息对话框。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>UnusualChineseChess-1.1.0 Release</title><link>https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-110-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-110-release/</guid><description>UnusualChineseChess Updates</description><pubDate>Fri, 09 Jan 2026 13:26:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/UnusualChineseChess&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-09 21:26] 1.1.0 &lt;a href=&quot;https://www.github.com/Samera2022/UnusualChineseChess/releases/tag/1.1.0&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;添加了更多的神奇玩法！&lt;/li&gt;
&lt;li&gt;添加“更新日志”和“关于作者”的按钮。&lt;/li&gt;
&lt;li&gt;添加本地翻转棋盘的功能。&lt;/li&gt;
&lt;li&gt;新增: “堆叠棋子”玩法(实验性玩法)，你现在可以将己方棋子堆叠到集中的某个位置了！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Changed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大幅修改项目逻辑以降低项目的耦合度，改为采用GameEngine&amp;lt;-GameRulesConfig-&amp;gt;MoveValidator进行各项配置的维护。&lt;/li&gt;
&lt;li&gt;由于“堆叠棋子”玩法，你现在可能需要使用左键来选择棋子，右键来进行棋子移动了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Fixed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;修复“左右连通”的逻辑，它现在应该能够兼容其他模式了。&lt;/li&gt;
&lt;li&gt;修复局域网持方的问题，现在局域网能够正常进行对局了！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Warn]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;“堆叠棋子”目前仍然存在一些bug，并未完成。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>UnusualChineseChess-1.1.0-26m01b Release</title><link>https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-110-26m01b-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-110-26m01b-release/</guid><description>UnusualChineseChess Updates</description><pubDate>Fri, 09 Jan 2026 09:42:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/UnusualChineseChess&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-09 17:42] 1.1.0-26m01b &lt;a href=&quot;https://www.github.com/Samera2022/UnusualChineseChess/releases/tag/1.1.0-26m01b&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;新增: “堆叠棋子”玩法，你现在可以将己方棋子堆叠到集中的某个位置了！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Changed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大幅修改项目逻辑以降低项目的耦合度，改为采用GameEngine&amp;lt;-GameRulesConfig-&amp;gt;MoveValidator进行各项配置的维护。&lt;/li&gt;
&lt;li&gt;由于“堆叠棋子”玩法，你现在可能需要使用左键来选择棋子，右键来进行棋子移动了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Fixed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;修复“左右连通”的逻辑，它现在应该能够兼容其他模式了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Warn]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;局域网的持方功能目前仍然存在一些问题，不建议本地主机选择持黑方。&lt;/li&gt;
&lt;li&gt;“堆叠棋子”目前仍然存在一些bug，并未完成。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>UnusualChineseChess-1.1.0-26m01a Release</title><link>https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-110-26m01a-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-110-26m01a-release/</guid><description>UnusualChineseChess Updates</description><pubDate>Wed, 07 Jan 2026 11:33:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/UnusualChineseChess&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-07 19:33] 1.1.0-26m01a &lt;a href=&quot;https://www.github.com/Samera2022/UnusualChineseChess/releases/tag/1.1.0-26m01a&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;添加了更多的神奇玩法！&lt;/li&gt;
&lt;li&gt;添加“更新日志”和“关于作者”的按钮。&lt;/li&gt;
&lt;li&gt;添加本地翻转棋盘的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Warn]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;局域网的持方功能存在一点问题，不建议本地主机选择持黑方。&lt;/li&gt;
&lt;li&gt;“左右连通”功能目前和其他玩法可能存在不适配。放心，这不会造成崩溃，只是有些其他玩法的棋子无法做到左右连通的效果。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>UnusualChineseChess-1.0.0 Release</title><link>https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-100-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-100-release/</guid><description>UnusualChineseChess Updates</description><pubDate>Wed, 07 Jan 2026 07:37:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/UnusualChineseChess&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-07 15:37] 1.0.0 &lt;a href=&quot;https://www.github.com/Samera2022/UnusualChineseChess/releases/tag/1.0.0&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;添加了完整的残局功能！你现在可以导出和导入残局了！&lt;/li&gt;
&lt;li&gt;添加了局域网对战功能！你现在可以邀请不同玩家来一起玩象棋了！&lt;/li&gt;
&lt;li&gt;添加“玩法”功能，你可以打破传统中国象棋中的一些规则，体验更加独特的中国象棋了！&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>UnusualChineseChess-0.2.0 Release</title><link>https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-020-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-020-release/</guid><description>UnusualChineseChess Updates</description><pubDate>Tue, 06 Jan 2026 16:18:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/UnusualChineseChess&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-07 00:18] 0.2.0 &lt;a href=&quot;https://www.github.com/Samera2022/UnusualChineseChess/releases/tag/0.2.0&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;美化了象棋棋盘和整体UI布局。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>UnusualChineseChess-0.1.0 Release</title><link>https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-010-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/unusualchinesechess/unusualchinesechess-010-release/</guid><description>UnusualChineseChess Updates</description><pubDate>Tue, 06 Jan 2026 15:54:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/UnusualChineseChess&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-06 23:54] 0.1.0 &lt;a href=&quot;https://www.github.com/Samera2022/UnusualChineseChess/releases/tag/0.1.0&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;支持进行基本的象棋游玩。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>MouseMacros-1.2.2 Release</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-122-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-122-release/</guid><description>MouseMacros Updates</description><pubDate>Mon, 05 Jan 2026 13:59:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-05 21:59] 1.2.2 &lt;a href=&quot;https://www.github.com/Samera2022/MouseMacros/releases/tag/1.2.2&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Fixed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;删除了AboutDialog中未被使用的tooltip。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>About MouseMacros</title><link>https://samera2022.github.io/posts/projects/mousemacros/aboutmousemacros/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/aboutmousemacros/</guid><description>About MouseMacros</description><pubDate>Sun, 04 Jan 2026 16:00:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;你好，这里是&lt;code&gt;Projects/MouseMacros&lt;/code&gt;。欢迎收听&lt;code&gt;About MouseMacros&lt;/code&gt;，我是主持人Samera2022。今天我们就来聊一聊&lt;code&gt;MouseMacros&lt;/code&gt;的一些简单介绍，以及我为什么要开发&lt;code&gt;MouseMacros&lt;/code&gt;这个项目。&lt;/p&gt;
&lt;h1&gt;Why &lt;code&gt;MouseMacros&lt;/code&gt; is a better choice?&lt;/h1&gt;
&lt;p&gt;如果你打开github搜索&lt;code&gt;mouse-recorder&lt;/code&gt;,&lt;code&gt;auto-clicker&lt;/code&gt;,&lt;code&gt;mouse-macro&lt;/code&gt;等词条，或者打开google搜索&lt;code&gt;Mouse Macros&lt;/code&gt;的话，你很可能会见到雪花般的鼠标宏项目。但是，让我们变得实际一点，这里面的很多项目其实并不适合用户使用。
:::note
首先我想向下文提到的开源作者们致敬，尽管他们的项目可能存在一些问题，但是他们践行了宝贵的开源精神！此外，需要注意的是，我对他们项目的看法也可能并不正确。如果您有别的见解，欢迎来联系我，我们可以进行更加深入的讨论。
:::
:::note
抱歉，我可能会引用别人的仓库。如果您是仓库的作者，并且不希望您的仓库出现在这里，请联系我，我会立刻撤下。
:::
不妨让我们简单地举出一些例子：&lt;/p&gt;
&lt;p&gt;↓该项目不具有Releases，其初衷并非服务用户，这只是自己的开发备份。
::github{repo=&quot;jborza/mouse-macros&quot;}
↓该项目具有Releases，但是相关功能和GUI均比较简陋。
::github{repo=&quot;n43e120/MouseMacro&quot;}
↓该项目具有Releases和较为美观的GUI，但是相关功能较少。
::github{repo=&quot;guinhx/ActionRecorder&quot;}
↓该项目具有Releases，美观的GUI与（和前者相比）比较多的功能，但是文件包过大。
::github{repo=&quot;p6laris/SnapClicker&quot;}
:::note
就最后一个项目而言，它的总体功能数比&lt;code&gt;MouseMacros&lt;/code&gt;要少很多，但是其文件包大小基本为&lt;code&gt;MouseMacros&lt;/code&gt;的两倍。这是我评价其文件包过大的依据。
:::
这些事情不止发生在这些项目，甚至可以说，你看到的很多项目（包括github以外的，有些甚至还有可能是付费的）很可能都有以上的弊端。而&lt;code&gt;MouseMacros&lt;/code&gt;则在&lt;code&gt;功能多-臃肿&lt;/code&gt;中取得了一个恰当的平衡。首先&lt;code&gt;MouseMacros&lt;/code&gt;是免费的开源项目，其诞生的初衷就是为了服务用户，让用户以一种Straight-forward的方式快捷地享受鼠标宏所带来的便利。因此，常用的功能，我选择直接放在&lt;code&gt;MainFrame&lt;/code&gt;中。对于需求简单的用户直接点击“开始”和“结束”就可以了。&lt;/p&gt;
&lt;p&gt;而对于要求略高的用户，他们可以选择在&lt;code&gt;SettingsDialog&lt;/code&gt;和&lt;code&gt;MacroSettingsDialog&lt;/code&gt;中进行更进一步的个性化设置，我也将一些比较常用的功能内置在了这两个设置窗体中。而对于一些“窗体大小”、“关闭方式”、“历史保存地址”等并不那么直接，但又切实显著地影响到使用体验的功能，我选择直接放在cache.json中，由程序自动配置，进而降低用户的信息熵与决策成本。&lt;/p&gt;
&lt;p&gt;制作一个鼠标宏是快速的，但是制作一个&lt;code&gt;好用的&lt;/code&gt;鼠标宏却并非轻松。制作一个&lt;code&gt;用户友好&lt;/code&gt;的鼠标宏则需要更加多的时间投入和精力投入以进行打磨。&lt;/p&gt;
&lt;h1&gt;Why I chose to develop &lt;code&gt;MouseMacros&lt;/code&gt;?&lt;/h1&gt;
&lt;p&gt;这在其他地方没有提到，但我是一个P社&lt;code&gt;Paradox&lt;/code&gt;玩家。具体地说，我主要游玩群星&lt;code&gt;Stellaris&lt;/code&gt;，并且偏向于其中的一个神奇的流派——智能机械格式塔扩张流派——或者更简单地说，塔械爆铺流。我在里面需要手动操作上百个球，这并非夸张。在我的一个千星存档中，我甚至需要直接操作230个殖民地！这听起来很吓人，实际上也确实是的。不过这么多殖民地也为我带来了巨大的资源收益。言归正传，我对于每种资源都有特定的产出专精模式。用另一种话说，这两百多个殖民地其实共用了相同的几个建筑的模板。而我想要建设这些殖民地，这意味着我需要整整操作230次。当我在漫长的游戏时间中真的完成了这一项工作，我觉得这是非常令人疲劳的。因此我寻找是否有这样一种方便轻松的方式，能够替代我执行相同的动作。&lt;/p&gt;
&lt;p&gt;第一时间，我想到了&lt;code&gt;宏鼠标&lt;/code&gt;。这是一种昂贵的鼠标，在生产时就预置了&lt;code&gt;鼠标宏&lt;/code&gt;的功能。我不想额外花费金钱，因此我选择去互联网寻找功能相似的软件。不幸的是，我在简体中文互联网上寻找到的软件大多具有广告，或者需要付费（不是买断制，是定期订阅）。我又在除简体中文互联网以外的地方寻找，发现情况稍微好些，至少它们的GUI看起来更加现代化，但是仍然存在高昂买断价格的问题。而对于那些免费的软件，他们的功能过于简单，不足以满足我的需求。同时，他们简陋的发布网页和非常简陋GUI界面（注：现代化的GUI是针对昂贵的买断软件而言的），以及他们所在的不知名的小网站，使我害怕我的电脑感染恶意软件。&lt;/p&gt;
&lt;p&gt;究其根本，最关键的问题在于&lt;code&gt;免费的软件各个方面都过于简陋以至于我不敢贸然使用&lt;/code&gt;而&lt;code&gt;看起来不错的软件价格高昂&lt;/code&gt;。更进一步地，当时我在github上并没有发现很多功能相似的仓库，即便有，也几乎没有给出能直接使用的Releases。（后来被证实，这是因为那些仓库用了诸如&lt;code&gt;auto-clicker&lt;/code&gt;等其他的标签和名字，以至于我完全没有检索到。）然而，我认为制作一个鼠标宏在技术上是比较清晰的。因此我对于这个现象感到困惑，所以决定尝试自己开发一款&lt;code&gt;MouseMacros&lt;/code&gt;的软件，想看看这到底有多困难。事实证明，这相对地是比较轻松的一个工作。好吧，至少和我修改这个基于Astro的网页相比，这个还是较为轻松的。最开始我只是想着自己使用，也没有怎么考虑用户交互的事情。后来考虑到我也从开源社区中下载了很多软件，同时维护这个项目可以使我收获经验，所以我决定顺手将开发的成果贡献回开源社区。这也是我在推出1.0.0后仍然积极维护并推出了很多Releases的原因。&lt;/p&gt;
&lt;h1&gt;End&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;MouseMacros&lt;/code&gt;花费了我很多的心血，如果这确实帮到您的话，还请您不要吝啬手中的Star，为我点亮那颗星吧。
::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;hr /&gt;
</content:encoded></item><item><title>MouseMacros Readme</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacrosreadme/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacrosreadme/</guid><description>MouseMacros Readme</description><pubDate>Sun, 04 Jan 2026 16:00:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;h1&gt;MouseMacros&lt;/h1&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;
&amp;lt;img src=&quot;https://raw.githubusercontent.com/Samera2022/MouseMacros/main/docs/images/MouseMacrosIcon.png&quot; alt=&quot;MouseMacros Logo&quot; width=&quot;120&quot;&amp;gt;
&amp;lt;b&amp;gt;A lightweight, cross-platform Java tool for recording and replaying mouse and keyboard macros.&amp;lt;/b&amp;gt;
&amp;lt;br&amp;gt;
&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;h2&gt;Preview&lt;/h2&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;
&amp;lt;img src=&quot;https://raw.githubusercontent.com/Samera2022/MouseMacros/main/docs/images/MouseMacrosMainFrame.png&quot; width=&quot;400&quot; alt=&quot;Main Interface&quot;&amp;gt;
&amp;lt;sub style=&quot;font-size: 14px;&quot;&amp;gt;&amp;lt;i&amp;gt;The main interface of MouseMacros.&amp;lt;/i&amp;gt;&amp;lt;/sub&amp;gt;
&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;h2&gt;Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Comprehensive Recording&lt;/strong&gt;: Capture Mouse Left/Right/Middle clicks, Scroll Wheel movements, and Keyboard inputs seamlessly.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Global Hotkeys&lt;/strong&gt;: Control the application even when it&apos;s minimized. Fully customizable keys for:
&lt;ul&gt;
&lt;li&gt;Start/Stop Recording&lt;/li&gt;
&lt;li&gt;Play Macro&lt;/li&gt;
&lt;li&gt;Abort Operation (Emergency stop for runaway macros)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Multi-Language Support&lt;/strong&gt;: Built-in localization for &lt;strong&gt;English (US)&lt;/strong&gt; and &lt;strong&gt;Simplified Chinese&lt;/strong&gt;, other supported languages includes Japanese, Russian, Korean, Spanish and French.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Theme Engine&lt;/strong&gt;: Supports &lt;strong&gt;Light&lt;/strong&gt; and &lt;strong&gt;Dark&lt;/strong&gt; modes, with an option to follow system settings automatically.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Persistence&lt;/strong&gt;: Macros are saved as &lt;code&gt;.mmc&lt;/code&gt; (CSV-formatted) files, allowing for easy sharing and manual editing.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Smart Memory&lt;/strong&gt;: Remembers window sizes, last-used directories, and custom configurations across sessions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Floating Tooltip&lt;/strong&gt;: Shows helpful instructions and tips near the cursor for easier operation.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Getting Started&lt;/h2&gt;
&lt;h3&gt;Quick Launch&lt;/h3&gt;
&lt;p&gt;I. Jar User&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Make sure that you have installed JRE 1.8 or above. If not, you can download &lt;a href=&quot;https://www.oracle.com/technetwork/cn/java/javase/downloads/jre8-downloads-2133155-zhs.html&quot;&gt;HERE&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Download the latest &lt;code&gt;.jar&lt;/code&gt; file from the &lt;a href=&quot;https://github.com/Samera2022/MouseMacros/releases&quot;&gt;Releases&lt;/a&gt; page.&lt;/li&gt;
&lt;li&gt;Double-click the jar file OR use cmd to run the application:&lt;pre&gt;&lt;code&gt;java -jar MouseMacros.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;II. Exe User&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Download the latest &lt;code&gt;.exe&lt;/code&gt; file from the &lt;a href=&quot;https://github.com/Samera2022/MouseMacros/releases&quot;&gt;Releases&lt;/a&gt; page.&lt;/li&gt;
&lt;li&gt;Click to start! All environments are integrated into one &lt;code&gt;exe&lt;/code&gt; file!&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Usage&lt;/h3&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;
&amp;lt;img src=&quot;https://raw.githubusercontent.com/Samera2022/MouseMacros/main/docs/images/MouseMacrosSettingsDialog.png&quot; width=&quot;400&quot; alt=&quot;Settings Dialog&quot;&amp;gt;
&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Adjust&lt;/strong&gt;: The choose of language will determine the words in the frame, thus resulting in some buttons not being displayed in the frame.
In this case, you will need to adjust the frame to the appropriate size.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Configure&lt;/strong&gt;: Open the Settings dialog and Macros Settings dialog to set your preferred hotkeys. For detailed configuration docs, please refer to &lt;a href=&quot;#configuration&quot;&gt;Configuration&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Record&lt;/strong&gt;: Press your &quot;Start Recording&quot; hotkey or press this button in the frame and perform the actions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Save&lt;/strong&gt;: Use &quot;Save Macros&quot; to export your recording to a &lt;code&gt;.mmc&lt;/code&gt; file.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Replay&lt;/strong&gt;: Use &quot;Load Macro&quot; to load a &lt;code&gt;.mmc&lt;/code&gt; file and press &quot;Play Macro&quot;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Configuration&lt;/h2&gt;
&lt;p&gt;The application stores settings in the user&apos;s AppData directory:
&lt;code&gt;%USERPROFILE%/AppData/MouseMacros/&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;File&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;config.cfg&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Stores UI language, theme mode, key mappings, and default storage path.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cache.json&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Stores recent file paths and window dimensions.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;Settings Dialog Options&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Follow System Settings&lt;/td&gt;
&lt;td&gt;&lt;code&gt;followSystemSettings&lt;/code&gt;(boolean)&lt;/td&gt;
&lt;td&gt;Controls whether to follow System default settings or not.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Switch Language&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lang&lt;/code&gt;(String)&lt;/td&gt;
&lt;td&gt;If &lt;code&gt;followSystemSettings&lt;/code&gt; is false, you can use this combo box to choose another display language.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Enable Dark Mode&lt;/td&gt;
&lt;td&gt;&lt;code&gt;enableDarkMode&lt;/code&gt;(boolean)&lt;/td&gt;
&lt;td&gt;If &lt;code&gt;followSystemSettings&lt;/code&gt; is false, you can use this check box to choose whether to enable Dark Mode.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Enable Default Storage&lt;/td&gt;
&lt;td&gt;&lt;code&gt;enableDefaultStorage&lt;/code&gt;(boolean)&lt;/td&gt;
&lt;td&gt;Controls whether to enable &lt;code&gt;defaultMmcStoragePath&lt;/code&gt;. If it is true, the &lt;code&gt;lastSaveDirectory&lt;/code&gt; and &lt;code&gt;lastLoadDirectory&lt;/code&gt; in cache.json will be ignored. Every time you open the FileChooserDialog(in &quot;Save Macro&quot; and &quot;Load Macro&quot;), it will automatically open the folder with &lt;code&gt;defaultMmcStoragePath&lt;/code&gt;. The same applies in reverse.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Default MouseMacros Storage Path&lt;/td&gt;
&lt;td&gt;&lt;code&gt;defaultMmcStoragePath&lt;/code&gt;(String)&lt;/td&gt;
&lt;td&gt;If &lt;code&gt;followSystemSettings&lt;/code&gt; is true, it will determine the default folder everytime you open the FileChooserDialog(in &quot;Save Macro&quot; and &quot;Load Macro&quot;). If the folder in this option doesn&apos;t exist, the app will first attempt to create this folder, otherwise it will automatically open the default folder(Your User Document Folder).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Enable Quick Mode&lt;/td&gt;
&lt;td&gt;&lt;code&gt;enableQuickMode&lt;/code&gt;(boolean)&lt;/td&gt;
&lt;td&gt;Controls whether to enable no-delay mode. In this mode, MouseMacros will ignore the waiting time between each mouse/keyboard action. It is DANGEROUS, and it is STRONGLY ADVISED to set a proper &lt;strong&gt;Abort Operation&lt;/strong&gt; Hotkey and the &lt;strong&gt;Repeat Delay&lt;/strong&gt; in &lt;strong&gt;Macro Settings Dialog&lt;/strong&gt; before you enable this mode.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Allow Long Tooltip&lt;/td&gt;
&lt;td&gt;&lt;code&gt;allowLongStr&lt;/code&gt;(boolean)&lt;/td&gt;
&lt;td&gt;Controls whether to enable LongTooltip Display. If false, MouseMacros will display all tooltips in a given width, otherwise MouseMacros will attempt to display them in a long line unless exceeding the frame (if so, it will wrap lines and display it in two or more long lines).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Readjust Frame Mode&lt;/td&gt;
&lt;td&gt;&lt;code&gt;readjustFrameMode&lt;/code&gt;(String)&lt;/td&gt;
&lt;td&gt;Controls the mode to display the window at a 3:2 ratio when there is no cache. If a cache exists, after changing the language, MouseMacros can choose among the three modes from the previous step when processing &apos;historical window size&apos; and &apos;recommended window size&apos;. You will get more detailed information in tooltip.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;Macro Settings Dialog Options&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Enable Custom Macro Settings&lt;/td&gt;
&lt;td&gt;&lt;code&gt;enableCustomMacroSettings&lt;/code&gt;(boolean)&lt;/td&gt;
&lt;td&gt;Controls whether to enable custom macro settings.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Execution Repeat Times&lt;/td&gt;
&lt;td&gt;&lt;code&gt;repeatTime&lt;/code&gt;(int)&lt;/td&gt;
&lt;td&gt;If &lt;code&gt;enableCustomMacroSettings&lt;/code&gt; is true, MouseMacros will automatically repeat your Macro at the given times.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Repeat Delay (s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;repeatDelay&lt;/code&gt;(double)&lt;/td&gt;
&lt;td&gt;If &lt;code&gt;enableCustomMacroSettings&lt;/code&gt; is true, MouseMacros will postpone given time before the next execution. Supports three decimal places(to millisecond) at most.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Development Document&lt;/h2&gt;
&lt;p&gt;Detailed docs generated by DeepWiki is presented &lt;a href=&quot;docs/deepwiki-docs/README.md&quot;&gt;HERE&lt;/a&gt;. Notably, it may be outdated, since it was manually compiled by the author from DeepWiki.&lt;/p&gt;
&lt;p&gt;For more up-to-date documents, you can refer to &lt;a href=&quot;https://deepwiki.com/Samera2022/MouseMacros&quot;&gt;Samera2022/MouseMacros | DeepWiki&lt;/a&gt; or just click the badge at the top of the article. The website weekly updates this project&apos;s docs and provides a &quot;Refresh this wiki&quot; with &quot;Enter email to refresh&quot; button to force update the docs if it hasn&apos;t indexed yet.&lt;/p&gt;
&lt;h2&gt;Others&lt;/h2&gt;
&lt;h3&gt;Contributing&lt;/h3&gt;
&lt;p&gt;Contributions are welcome! If you find a bug or have a feature request, please open an issue.&lt;/p&gt;
&lt;h3&gt;Author&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Developer: Samera2022&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GitHub&lt;/strong&gt;: &lt;a href=&quot;https://github.com/Samera2022&quot;&gt;@Samera2022&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;License&lt;/h3&gt;
&lt;p&gt;This project is licensed under the GNU General Public License v3.0 License - see the &lt;code&gt;LICENSE&lt;/code&gt; file for details.&lt;/p&gt;
</content:encoded></item><item><title>MouseMacros-1.2.1 Release</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-121-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-121-release/</guid><description>MouseMacros Updates</description><pubDate>Sun, 04 Jan 2026 07:45:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-01 17:15] 1.2.1 &lt;a href=&quot;https://www.github.com/Samera2022/MouseMacros/releases/tag/1.2.1&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Fixed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;修正了ExitDialog的退出逻辑，使得不选单选框直接点结束时会直接销毁ExitDialog窗体。&lt;/li&gt;
&lt;li&gt;修正打包逻辑，1.2.0的打包结果实际上是1.2.0-26m01a的结果）））&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>MouseMacros-1.2.0 Release</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-120-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-120-release/</guid><description>MouseMacros Updates</description><pubDate>Fri, 02 Jan 2026 11:03:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-02 19:03] 1.2.0 &lt;a href=&quot;https://www.github.com/Samera2022/MouseMacros/releases/tag/1.2.0&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;为AboutDialog添加了Github跳转按钮。&lt;/li&gt;
&lt;li&gt;为SettingsDialog添加了readjustFrameMode选项。&lt;/li&gt;
&lt;li&gt;添加“建议窗体大小”功能。MouseMacros会在无cache的情况下尝试采用3:2的比例展示窗体。如果存在cache，那么在修改语言后MouseMacros处理“历史窗体大小”和“建议窗体大小”的过程中可以选择上一条中的三种模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Changed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;修正了打包逻辑，在该版本之前打包的exe应当全部改名为MouseMacros.exe才能正常运行。&lt;/li&gt;
&lt;li&gt;修改exe的文件名会导致无法找到启动文件……因此不建议修改发布时的程序名。&lt;/li&gt;
&lt;li&gt;修改了SettingsDialog的主界面，使其更加有条理。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>MouseMacros-1.2.0-26m01a Release</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-120-26m01a-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-120-26m01a-release/</guid><description>MouseMacros Updates</description><pubDate>Thu, 01 Jan 2026 09:15:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-01 17:15] 1.2.0-26m01a &lt;a href=&quot;https://www.github.com/Samera2022/MouseMacros/releases/tag/1.2.0-26m01a&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;为AboutDialog添加了Github跳转按钮。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Changed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;修正了打包逻辑，在该版本之前打包的exe应当全部改名为MouseMacros.exe才能正常运行。&lt;/li&gt;
&lt;li&gt;修改exe的文件名会导致无法找到启动文件……因此不建议修改发布时的程序名。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>MouseMacros-1.1.0 Release</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-110-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-110-release/</guid><description>MouseMacros Updates</description><pubDate>Thu, 01 Jan 2026 04:52:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-01 12:52] 1.1.0 &lt;a href=&quot;https://www.github.com/Samera2022/MouseMacros/releases/tag/1.1.0&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Info]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;从此版本开始，将严格按照语义化版本（SemVer）重新编写版号。&lt;/li&gt;
&lt;li&gt;在以往版本中，通常采用第三位表示小功能更新，第二位表示重构更新，第一位表示重大更新。现在将采用第三位表示修订更新，第二位表示次版本更新，第一位表示主版本更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Fixed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;修复了1.0.4中的Tooltip长文本显示相关逻辑，使之更加准确地生效。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>MouseMacros-1.0.4 Release</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-104-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-104-release/</guid><description>MouseMacros Updates</description><pubDate>Wed, 31 Dec 2025 16:00:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2026-01-01 00:00] 1.0.4 &lt;a href=&quot;https://www.github.com/Samera2022/MouseMacros/releases/tag/1.0.4&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;这是2026年新年的第一个release呢&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;添加了鼠标悬浮窗显示信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Changed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;修改了CacheManager的逻辑，使之和ConfigManager保持一致。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>MouseMacros-1.0.3 Release</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-103-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-103-release/</guid><description>MouseMacros Updates</description><pubDate>Wed, 31 Dec 2025 07:45:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2025-12-31 15:45] 1.0.3 &lt;a href=&quot;https://www.github.com/Samera2022/MouseMacros/releases/tag/1.0.3&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;这是2025年的最后一个release了呢&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;给每个窗体都添加上了压缩后的图标，使得程序窗体和任务栏图标不再使用Java的默认图标了。&lt;/li&gt;
&lt;li&gt;添加“最小化到系统托盘”的功能，在主窗体(MainFrame)关闭后会自动最小化到系统托盘。&lt;/li&gt;
&lt;li&gt;支持了更多的语言，包括西班牙语、法语、日语、韩语、俄语。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Changed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;修改了语言文件的部分键格式，使之条理更加清晰。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Fixed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;修正了Abort Operation的效果，使之可以在循环执行中正确地生效。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>MouseMacros-1.0.2 Release</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-102-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-102-release/</guid><description>MouseMacros Updates</description><pubDate>Sun, 28 Dec 2025 08:52:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2025-12-28 16:52] 1.0.2 &lt;a href=&quot;https://www.github.com/Samera2022/MouseMacros/releases/tag/1.0.2&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在SettingsDialog添加了QuickMode，现在MouseMacros可以无视鼠标键盘的等待时间，快速执行了。&lt;/li&gt;
&lt;li&gt;在MacroSettingsDialog的Enable Custom Macro Settings条目下添加了Execution Repeat Delay (s)，可以在每次重复的执行之中等待指定的秒数。秒数最大支持三位小数（到毫秒）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Fixed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1.0.0中不小心删除了Macro Settings的保存设置按钮，这次重新添加了进去。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>MouseMacros-1.0.1 Release</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-101-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-101-release/</guid><description>MouseMacros Updates</description><pubDate>Sat, 27 Dec 2025 15:16:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2025-12-27 23:16] 1.0.1 &lt;a href=&quot;https://www.github.com/Samera2022/MouseMacros/releases/tag/1.0.1&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将窗体大小添加进cache.json，现在MouseMacros将能记忆你的每个窗体的大小。&lt;/li&gt;
&lt;li&gt;为Settings添加enable_default_storage的按钮，具体逻辑详见Description。&lt;/li&gt;
&lt;li&gt;配置了一键打包的脚本，现在的Release将会提供exe版本的程序下载。&lt;/li&gt;
&lt;li&gt;为settings.custom_hotkey界面的TextField添加了鼠标焦点提示。&lt;/li&gt;
&lt;li&gt;引入DeepWiki的docs来辅助代码理解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Changed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;修改为更加细致的README.md。&lt;/li&gt;
&lt;li&gt;文件结构略有修改，主要是lang文件移动到src下。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Description]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当enable_default_storage为true时，在loadMacros和saveMacros时均只会采用config中的default_mmc_storage_path。且在FileChooser窗体中找到其他目录保存并不会修改cache.json中的lastSaveDirectory和lastLoadDirectory。&lt;/li&gt;
&lt;li&gt;当enable_default_storage为false时，在loadMacros和saveMacros时均只会采用cache.json中的lastSaveDirectory和lastLoadDirectory。当二者均为空时为默认目录，当二者其中一者为空时，在选择好文件夹（关闭FileChooser）后会默认将有值的数据复制到空的那一者。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Fixed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;修复了1.0.0中settings.custom_hotkey的异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[To-do]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可能考虑切换UIManager的样式，当前的Metal样式较为简陋且缺乏较多的属性，可能会考虑切换至Nimbus、System或者第三方的FlatLightLaf。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Note]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;源代码大概其实只有1MB左右的大小，但是带上精简的运行环境就需要34.2MB了……&lt;/li&gt;
&lt;li&gt;有人可能会说，为什么1.0.0的软件包要2.84MB，而这一次的只要1.05MB了呢？是不是压缩水平提升了？啊其实不是啊，是因为我之前不小心把项目的根目录放进源代码目录里面了……在我编写EVB和Jpackage打包的时候才发现这一点，然后才改过来。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>MouseMacros-1.0.0 Release</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-100-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-100-release/</guid><description>MouseMacros Updates</description><pubDate>Wed, 09 Jul 2025 13:31:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2025-07-09 21:31] 1.0.0 &lt;a href=&quot;https://www.github.com/Samera2022/MouseMacros/releases/tag/1.0.0&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;添加对鼠标中键，鼠标滚轮和键盘的支持&lt;/li&gt;
&lt;li&gt;区分了鼠标左键右键和中键&lt;/li&gt;
&lt;li&gt;添加自定义宏设置&lt;/li&gt;
&lt;li&gt;添加中止宏按键功能&lt;/li&gt;
&lt;li&gt;添加保留上次存储/读取鼠标宏路径的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Warn]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在创建settings.custom_hotkey界面后，不点击任何对话框直接按键盘，将会直接改动start_record的按键设置。&lt;/li&gt;
&lt;li&gt;JFileChooser的界面无法应用暗色模式……要重写这个类实在太费劲了。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>MouseMacros-0.1.0 Release</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-010-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-010-release/</guid><description>MouseMacros Updates</description><pubDate>Tue, 08 Jul 2025 07:08:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2025-07-08 15:08] 0.1.0
&lt;a href=&quot;https://www.github.com/Samera2022/MouseMacros/releases/tag/0.1.0&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;实装配置文件的keyMap&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Changed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;重构项目整体结构，降低代码耦合度&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>MouseMacros-0.0.2 Release</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-002-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-002-release/</guid><description>MouseMacros Updates</description><pubDate>Sun, 06 Jul 2025 14:51:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2025-07-06 22:51] 0.0.2
&lt;a href=&quot;https://www.github.com/Samera2022/MouseMacros/releases/tag/0.0.2&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;添加配置文件功能&lt;/li&gt;
&lt;li&gt;添加设置界面&lt;/li&gt;
&lt;li&gt;添加&quot;关于作者&quot;功能按钮&lt;/li&gt;
&lt;li&gt;添加&quot;更新日志&quot;功能按钮&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Changed]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将自定义热键功能移入&quot;设置&quot;界面&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Detailed]&lt;/h2&gt;
&lt;h3&gt;关于配置文件功能&lt;/h3&gt;
&lt;p&gt;目前已添加以下可配置项：
(boolean)跟随系统设置，(boolean)启用深色模式，(String)切换语言，(String)默认鼠标宏存储地址，&lt;a href=&quot;Map%3CString,String%3E&quot;&gt;未实装，不可用&lt;/a&gt;按键映射表，
注意：&quot;跟随系统设置&quot;与(&quot;启用深色模式&quot;, &quot;切换语言&quot;)存在上位关系。如果选择了&quot;跟随系统设置&quot;，那么后二者就不再接受用户更改，直接读取系统的相应设置。&lt;/p&gt;
</content:encoded></item><item><title>MouseMacros-0.0.1 Release</title><link>https://samera2022.github.io/posts/projects/mousemacros/mousemacros-001-release/</link><guid isPermaLink="true">https://samera2022.github.io/posts/projects/mousemacros/mousemacros-001-release/</guid><description>MouseMacros Updates</description><pubDate>Sat, 05 Jul 2025 12:20:00 GMT</pubDate><content:encoded>&lt;p&gt;::github{repo=&quot;Samera2022/MouseMacros&quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;text-align: center;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;[2025-07-05 20:20] 0.0.1
&lt;a href=&quot;https://www.github.com/Samera2022/MouseMacros/releases/tag/0.0.1&quot;&gt;Click here to Release&lt;/a&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h2&gt;[Added]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;添加开始/停止录制鼠标宏功能&lt;/li&gt;
&lt;li&gt;添加保存/读取鼠标宏功能&lt;/li&gt;
&lt;li&gt;添加自定义热键功能&lt;/li&gt;
&lt;li&gt;添加本地化支持&lt;/li&gt;
&lt;li&gt;添加自适应窗体（随按钮长度与系统缩放设置而改变）&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item></channel></rss>